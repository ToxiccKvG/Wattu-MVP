// @generated by Cursor AI (Claude) — verified by Kevin Mendy

/**
 * ═══════════════════════════════════════════════════════════
 * EXPORT SERVICE
 * Gestion des exports de données (CSV, PDF futur)
 * ═══════════════════════════════════════════════════════════
 */

/**
 * Colonnes disponibles pour l'export
 */
export const AVAILABLE_COLUMNS = [
  { key: 'id', label: 'ID', enabled: true },
  { key: 'commune_name', label: 'Commune', enabled: true },
  { key: 'type', label: 'Type', enabled: true },
  { key: 'description', label: 'Description', enabled: true },
  { key: 'status', label: 'Statut', enabled: true },
  { key: 'priority', label: 'Priorité', enabled: true },
  { key: 'created_at', label: 'Date', enabled: true },
  { key: 'citizen_name', label: 'Nom citoyen', enabled: true },
  { key: 'phone', label: 'Téléphone', enabled: false },
  { key: 'latitude', label: 'Latitude', enabled: true },
  { key: 'longitude', label: 'Longitude', enabled: true },
  { key: 'image_url', label: 'Photo URL', enabled: false },
  { key: 'code_suivi', label: 'Code suivi', enabled: false },
];

/**
 * Exporter des signalements en CSV avec colonnes personnalisées
 * 
 * @param {Array} reports - Array de signalements à exporter
 * @param {Array} selectedColumns - Array de clés de colonnes à inclure
 * @returns {string} - Contenu CSV
 * 
 * @example
 * const csv = exportToCSVCustom(reports, ['id', 'commune_name', 'type', 'status']);
 */
export function exportToCSVCustom(reports, selectedColumns) {
  if (!reports || reports.length === 0) {
    console.warn('⚠️ Aucun signalement à exporter');
    return '';
  }

  if (!selectedColumns || selectedColumns.length === 0) {
    console.warn('⚠️ Aucune colonne sélectionnée');
    return '';
  }

  // Créer le header CSV
  const columnLabels = selectedColumns
    .map(key => {
      const col = AVAILABLE_COLUMNS.find(c => c.key === key);
      return col ? col.label : key;
    })
    .join(',');

  // Créer les lignes CSV
  const rows = reports.map(report => {
    return selectedColumns.map(key => {
      let value = '';

      // Récupérer la valeur selon la clé
      if (key === 'commune_name') {
        value = report.commune?.name || '';
      } else if (key === 'type') {
        value = formatType(report.type);
      } else if (key === 'status') {
        value = formatStatus(report.status);
      } else if (key === 'priority') {
        value = formatPriority(report.priority);
      } else if (key === 'created_at') {
        value = formatDate(report.created_at);
      } else if (key === 'latitude' || key === 'longitude') {
        value = report[key] ? report[key].toFixed(6) : '';
      } else {
        value = report[key] || '';
      }

      // Échapper les virgules et guillemets
      return escapeCSV(value);
    }).join(',');
  });

  // Combiner header + rows
  const csv = [columnLabels, ...rows].join('\n');

  console.log(`✅ CSV généré: ${reports.length} lignes, ${selectedColumns.length} colonnes`);
  return csv;
}

/**
 * Télécharger un CSV
 * 
 * @param {string} csvContent - Contenu CSV
 * @param {string} [filename] - Nom du fichier (default: 'signalements-YYYY-MM-DD.csv')
 */
export function downloadCSV(csvContent, filename) {
  if (!csvContent) {
    console.error('❌ Contenu CSV vide');
    return;
  }

  // Générer nom de fichier avec date si non fourni
  const defaultFilename = `signalements-${new Date().toISOString().split('T')[0]}.csv`;
  const finalFilename = filename || defaultFilename;

  // Créer un Blob et déclencher le téléchargement
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = finalFilename;
  link.click();

  console.log(`✅ Téléchargement lancé: ${finalFilename}`);
}

/**
 * Générer un aperçu du nombre de lignes à exporter
 * 
 * @param {Array} reports - Signalements à exporter
 * @param {Array} selectedColumns - Colonnes sélectionnées
 * @returns {Object} - { row_count, column_count, estimated_size_kb }
 */
export function getExportPreview(reports, selectedColumns) {
  const rowCount = reports.length;
  const columnCount = selectedColumns.length;

  // Estimer la taille (approximatif: 50 bytes par cellule)
  const estimatedSizeBytes = rowCount * columnCount * 50;
  const estimatedSizeKb = Math.round(estimatedSizeBytes / 1024);

  return {
    row_count: rowCount,
    column_count: columnCount,
    estimated_size_kb: estimatedSizeKb
  };
}

/**
 * ═══════════════════════════════════════════════════════════
 * HELPER FUNCTIONS
 * ═══════════════════════════════════════════════════════════
 */

/**
 * Échapper les valeurs CSV (virgules, guillemets)
 */
function escapeCSV(value) {
  if (value === null || value === undefined) return '';

  const stringValue = String(value);

  // Si contient virgule ou guillemets, entourer de guillemets
  if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n')) {
    return `"${stringValue.replace(/"/g, '""')}"`;
  }

  return stringValue;
}

/**
 * Formater le type de signalement
 */
function formatType(type) {
  const types = {
    'road': 'Voirie',
    'lighting': 'Éclairage public',
    'water': 'Fuite d\'eau',
    'waste': 'Déchets',
    'security': 'Sécurité',
    'other': 'Autre'
  };
  return types[type] || type;
}

/**
 * Formater le statut
 */
function formatStatus(status) {
  const statuses = {
    'pending': 'En attente',
    'in_progress': 'En cours',
    'resolved': 'Résolu',
    'rejected': 'Rejeté'
  };
  return statuses[status] || status;
}

/**
 * Formater la priorité
 */
function formatPriority(priority) {
  const priorities = {
    'low': 'Faible',
    'normal': 'Normal',
    'high': 'Élevée',
    'urgent': 'Urgent'
  };
  return priorities[priority] || priority;
}

/**
 * Formater la date
 */
function formatDate(dateString) {
  if (!dateString) return '';

  const date = new Date(dateString);
  const day = String(date.getDate()).padStart(2, '0');
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const year = date.getFullYear();
  const hours = String(date.getHours()).padStart(2, '0');
  const minutes = String(date.getMinutes()).padStart(2, '0');

  return `${day}/${month}/${year} ${hours}:${minutes}`;
}

export default {
  exportToCSVCustom,
  downloadCSV,
  getExportPreview,
  AVAILABLE_COLUMNS
};

