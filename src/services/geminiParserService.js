// @generated by Cursor AI (Claude) — verified by Kevin

import { GoogleGenAI } from '@google/genai';
import geminiConfig from '@/config/gemini';

/**
 * Service d'extraction de données structurées via Gemini API
 * 
 * Utilise Gemini pour extraire des informations (email, commune, adresse)
 * depuis des transcriptions vocales avec une meilleure compréhension du langage naturel.
 * 
 * Fonctionnalités :
 * - Extraction d'email depuis texte vocal
 * - Identification de commune depuis texte
 * - Normalisation d'adresse depuis texte
 * - Fallback gracieux si l'API n'est pas disponible
 */

let geminiClient = null;

/**
 * Initialiser le client Gemini
 */
function getGeminiClient() {
  if (!geminiConfig.enabled) {
    return null;
  }

  if (!geminiClient) {
    try {
      // Dans le navigateur, GoogleGenAI attend un objet avec apiKey
      geminiClient = new GoogleGenAI({ apiKey: geminiConfig.apiKey });
    } catch (error) {
      console.error('❌ Erreur initialisation Gemini:', error);
      return null;
    }
  }

  return geminiClient;
}

/**
 * Extraire un email depuis un texte transcrit vocalement
 * 
 * @param {string} text - Texte transcrit contenant potentiellement un email
 * @returns {Promise<string|null>} - Email extrait ou null
 * 
 * @example
 * await extractEmailWithAI("mon email est amadou point diallo at gmail point com")
 * // → "amadou.diallo@gmail.com"
 */
export async function extractEmailWithAI(text) {
  if (!text || typeof text !== 'string' || text.trim() === '') {
    return null;
  }

  const client = getGeminiClient();
  if (!client) {
    return null; // Fallback vers le parser classique
  }

  try {
    const prompt = `Tu es un assistant qui extrait des adresses email depuis des transcriptions vocales.

Texte transcrit : "${text}"

Extrais l'adresse email de ce texte. Les utilisateurs peuvent dire :
- "point" pour "."
- "at" ou "a" pour "@"
- "gmail point com" pour "gmail.com"

Réponds UNIQUEMENT avec l'email extrait, sans explication, ou "null" si aucun email n'est trouvé.
Format attendu : email@domain.com ou null`;

    const response = await client.models.generateContent({
      model: geminiConfig.model,
      contents: [{ parts: [{ text: prompt }] }],
    });

    const result = response.candidates?.[0]?.content?.parts?.[0]?.text?.trim();

    if (!result || result.toLowerCase() === 'null') {
      return null;
    }

    // Vérifier que c'est un email valide
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (emailRegex.test(result)) {
      return result.toLowerCase();
    }

    return null;
  } catch (error) {
    console.error('❌ Erreur extraction email avec Gemini:', error);
    return null; // Fallback vers le parser classique
  }
}

/**
 * Identifier une commune depuis un texte transcrit
 * 
 * @param {string} text - Texte transcrit contenant potentiellement un nom de commune
 * @param {Array} communes - Liste des communes disponibles [{ id, name, region }]
 * @returns {Promise<string|null>} - ID de la commune trouvée ou null
 * 
 * @example
 * await identifyCommuneWithAI("j'habite à dakar plateau", communes)
 * // → "uuid-de-dakar"
 */
export async function identifyCommuneWithAI(text, communes = []) {
  if (!text || typeof text !== 'string' || text.trim() === '' || !Array.isArray(communes) || communes.length === 0) {
    return null;
  }

  const client = getGeminiClient();
  if (!client) {
    return null; // Fallback vers le parser classique
  }

  try {
    // Créer une liste des noms de communes pour le contexte
    const communeNames = communes.map(c => `${c.name} (${c.region})`).join(', ');

    const prompt = `Tu es un assistant qui identifie des communes sénégalaises depuis des transcriptions vocales.

Texte transcrit : "${text}"

Liste des communes disponibles :
${communeNames}

Identifie la commune mentionnée dans le texte. Réponds UNIQUEMENT avec le nom exact de la commune (sans la région), ou "null" si aucune commune n'est trouvée.
Exemple de réponse : "Dakar" ou "Saint-Louis" ou "null"`;

    const response = await client.models.generateContent({
      model: geminiConfig.model,
      contents: [{ parts: [{ text: prompt }] }],
    });

    const result = response.candidates?.[0]?.content?.parts?.[0]?.text?.trim();

    if (!result || result.toLowerCase() === 'null') {
      return null;
    }

    // Chercher la commune correspondante
    const normalizedResult = result.toLowerCase().trim();
    const foundCommune = communes.find(c => 
      c.name.toLowerCase() === normalizedResult ||
      c.name.toLowerCase().includes(normalizedResult) ||
      normalizedResult.includes(c.name.toLowerCase())
    );

    return foundCommune ? foundCommune.id : null;
  } catch (error) {
    console.error('❌ Erreur identification commune avec Gemini:', error);
    return null; // Fallback vers le parser classique
  }
}

/**
 * Normaliser une adresse depuis un texte transcrit
 * 
 * @param {string} text - Texte transcrit contenant une adresse
 * @returns {Promise<string|null>} - Adresse normalisée ou null
 * 
 * @example
 * await normalizeAddressWithAI("rue douze quartier plateau dakar")
 * // → "Rue 12, quartier Plateau, Dakar"
 */
export async function normalizeAddressWithAI(text) {
  if (!text || typeof text !== 'string' || text.trim() === '') {
    return null;
  }

  const client = getGeminiClient();
  if (!client) {
    return null; // Fallback vers le parser classique
  }

  try {
    const prompt = `Tu es un assistant qui normalise des adresses depuis des transcriptions vocales.

Texte transcrit : "${text}"

Normalise cette adresse en :
- Corrigeant les erreurs de transcription
- Ajoutant la ponctuation appropriée
- Mettant en forme (première lettre en majuscule)
- Préservant tous les détails (numéros de rue, quartiers, etc.)

Réponds UNIQUEMENT avec l'adresse normalisée, sans explication, ou "null" si l'adresse est invalide.
Exemple : "Rue 12, quartier Plateau, Dakar"`;

    const response = await client.models.generateContent({
      model: geminiConfig.model,
      contents: [{ parts: [{ text: prompt }] }],
    });

    const result = response.candidates?.[0]?.content?.parts?.[0]?.text?.trim();

    if (!result || result.toLowerCase() === 'null' || result.length < 5) {
      return null;
    }

    return result;
  } catch (error) {
    console.error('❌ Erreur normalisation adresse avec Gemini:', error);
    return null; // Fallback vers le parser classique
  }
}

/**
 * Vérifier si le service Gemini est disponible
 * 
 * @returns {boolean}
 */
export function isGeminiAvailable() {
  return geminiConfig.enabled && getGeminiClient() !== null;
}

export default {
  extractEmailWithAI,
  identifyCommuneWithAI,
  normalizeAddressWithAI,
  isGeminiAvailable,
};

