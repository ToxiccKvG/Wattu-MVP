// @generated by Cursor AI (Claude) — verified by Kevin Mendy
import { authApi } from '@/api/authApi';
import { getSecureErrorMessage } from '@/utils/errorMessages';

/**
 * Service Layer pour l'authentification
 * 
 * Rôle : Logique métier + Transformation des erreurs en messages sécurisés
 * 
 * Architecture :
 * - Utilise authApi.js pour les appels Supabase
 * - Capture TOUTES les erreurs
 * - Transforme en messages utilisateur sécurisés (via errorMessages.js)
 * - Retourne toujours { success: true/false, data/error }
 * 
 * Sécurité :
 * - Ne JAMAIS exposer les erreurs techniques Supabase
 * - Toujours utiliser getSecureErrorMessage()
 */
export const authService = {
  /**
   * Connexion complète d'un utilisateur
   * 
   * Process :
   * 1. Appel authApi.signIn() pour authentifier
   * 2. Appel authApi.getUserProfile() pour récupérer role/commune
   * 3. Retourne user complet avec session
   * 4. Si erreur → Transformation en message sécurisé
   * 
   * @param {string} email - Email de l'utilisateur
   * @param {string} password - Mot de passe
   * @param {string} language - Langue pour messages d'erreur ('fr' | 'wo')
   * @returns {Promise<{success: boolean, user?: Object, session?: Object, error?: string}>}
   * 
   * Exemple succès :
   * {
   *   success: true,
   *   user: { id, name, email, role: 'agent', commune_id },
   *   session: { access_token, refresh_token, ... }
   * }
   * 
   * Exemple erreur :
   * {
   *   success: false,
   *   error: "Email ou mot de passe incorrect"
   * }
   */
  async login(email, password, language = 'fr') {
    try {
      // Validation basique côté client (avant appel API)
      if (!email || !password) {
        return {
          success: false,
          error: language === 'fr' 
            ? 'Email et mot de passe requis' 
            : 'Email ak mot de passe amoul dara',
        };
      }

      // Étape 1 : Authentification via Supabase Auth
      const { user: authUser, session } = await authApi.signIn(email, password);

      // Étape 2 : Récupération du profil complet (role, commune, name)
      const userProfile = await authApi.getUserProfile(authUser.id);

      // Étape 3 : Fusion des données
      const completeUser = {
        ...userProfile,
        email: authUser.email, // S'assurer qu'on a l'email
      };

      // Succès : Retourner user + session
      return {
        success: true,
        user: completeUser,
        session,
      };

    } catch (error) {
      // ⭐ SÉCURITÉ : Transformer l'erreur en message sécurisé
      const secureMessage = getSecureErrorMessage(error, language);

      return {
        success: false,
        error: secureMessage,
      };
    }
  },

  /**
   * Déconnexion de l'utilisateur
   * 
   * Process :
   * 1. Appel authApi.signOut() pour invalider la session Supabase
   * 2. Retourne succès ou erreur sécurisée
   * 
   * @param {string} language - Langue pour messages d'erreur
   * @returns {Promise<{success: boolean, error?: string}>}
   */
  async logout(language = 'fr') {
    try {
      await authApi.signOut();

      return {
        success: true,
      };

    } catch (error) {
      // Transformer l'erreur en message sécurisé
      const secureMessage = getSecureErrorMessage(error, language);

      return {
        success: false,
        error: secureMessage,
      };
    }
  },

  /**
   * Récupère l'utilisateur actuellement connecté
   * 
   * Utilisé au chargement de l'app pour vérifier si une session existe
   * 
   * Process :
   * 1. Appel authApi.getSession() pour vérifier session active
   * 2. Si session existe → Récupérer le profil complet
   * 3. Retourne user ou null
   * 
   * @returns {Promise<{success: boolean, user?: Object, error?: string}>}
   * 
   * Exemple succès avec user :
   * {
   *   success: true,
   *   user: { id, name, email, role, commune_id }
   * }
   * 
   * Exemple succès sans user (pas de session) :
   * {
   *   success: true,
   *   user: null
   * }
   */
  async getCurrentUser() {
    try {
      // Récupérer la session active
      const session = await authApi.getSession();

      // Pas de session = pas d'utilisateur connecté
      if (!session || !session.user) {
        return {
          success: true,
          user: null,
        };
      }

      // Session existe → Récupérer le profil complet
      const userProfile = await authApi.getUserProfile(session.user.id);

      return {
        success: true,
        user: {
          ...userProfile,
          email: session.user.email,
        },
      };

    } catch (error) {
      // Si erreur (ex: session expirée), retourner null
      // (on ne veut pas afficher d'erreur à l'utilisateur au chargement de l'app)
      console.error('Erreur récupération user:', error);

      return {
        success: true,
        user: null,
      };
    }
  },

  /**
   * Détermine la route de redirection selon le rôle de l'utilisateur
   * 
   * Utilisé après login réussi pour rediriger vers le bon dashboard
   * 
   * @param {string} role - Rôle de l'utilisateur ('agent' | 'admin')
   * @returns {string} Path de redirection
   * 
   * Exemple :
   * getRedirectPath('agent') → '/agent/dashboard'
   * getRedirectPath('admin') → '/admin/dashboard'
   */
  getRedirectPath(role) {
    const redirectPaths = {
      agent: '/agent/dashboard',
      admin: '/admin/dashboard',
    };

    return redirectPaths[role] || '/'; // Fallback vers home si rôle inconnu
  },

  /**
   * Valide le format d'un email
   * 
   * @param {string} email - Email à valider
   * @returns {boolean} true si email valide
   */
  isValidEmail(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  },

  /**
   * Valide la force d'un mot de passe
   * 
   * Règles :
   * - Minimum 6 caractères
   * 
   * @param {string} password - Mot de passe à valider
   * @returns {boolean} true si password valide
   */
  isValidPassword(password) {
    return password && password.length >= 6;
  },
};

export default authService;

