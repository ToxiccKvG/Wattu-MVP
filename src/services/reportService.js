// @generated by Cursor AI (Claude) ‚Äî verified by Kevin Mendy
import imageCompression from 'browser-image-compression';
import * as reportApi from '@/api/reportApi';
import * as storageApi from '@/api/storageApi';

/**
 * Service Layer pour les signalements (reports)
 * 
 * Logique m√©tier :
 * - Compression d'images avant upload
 * - Validation des donn√©es du formulaire
 * - Orchestration entre uploadImage + createReport
 * - Transformation des erreurs en messages user-friendly
 * 
 * Note : Ce layer ne fait PAS d'appels directs √† Supabase
 * Il utilise les APIs (reportApi, storageApi)
 */

/**
 * Options de compression d'image par d√©faut
 */
const COMPRESSION_OPTIONS = {
  maxSizeMB: 1,              // Taille maximale : 1MB apr√®s compression
  maxWidthOrHeight: 1920,     // Largeur/hauteur max : 1920px
  useWebWorker: true,         // Utiliser un Web Worker pour ne pas bloquer le UI
  fileType: 'image/jpeg'      // Convertir en JPEG pour optimiser la taille
};

/**
 * Comprimer une image avant upload
 * 
 * @param {File} file - Fichier image √† comprimer
 * @param {Object} [options] - Options de compression (override default)
 * 
 * @returns {Promise<{compressedFile: File|null, originalSize: number, compressedSize: number, error: Object|null}>}
 * 
 * @example
 * const result = await compressImage(file);
 * if (result.error) {
 *   console.error('Erreur compression:', result.error.message);
 * } else {
 *   console.log('Compression:', result.originalSize, '‚Üí', result.compressedSize);
 *   // Utiliser result.compressedFile pour l'upload
 * }
 */
export async function compressImage(file, options = {}) {
  try {
    if (!file) {
      return {
        compressedFile: null,
        originalSize: 0,
        compressedSize: 0,
        error: {
          message: 'Aucun fichier fourni',
          code: 'NO_FILE'
        }
      };
    }

    // Validation : type d'image autoris√©
    if (!storageApi.isAllowedImageType(file.type)) {
      return {
        compressedFile: null,
        originalSize: file.size,
        compressedSize: 0,
        error: {
          message: 'Type de fichier non autoris√© (JPEG, PNG, WebP uniquement)',
          code: 'INVALID_FILE_TYPE'
        }
      };
    }

    const originalSize = file.size;
    console.log(`üóúÔ∏è Compression en cours... (Taille originale: ${(originalSize / 1024).toFixed(2)}KB)`);

    // Compression avec options par d√©faut (ou override)
    const compressedFile = await imageCompression(file, {
      ...COMPRESSION_OPTIONS,
      ...options
    });

    const compressedSize = compressedFile.size;
    const compressionRatio = ((1 - compressedSize / originalSize) * 100).toFixed(1);

    console.log(`‚úÖ Compression r√©ussie: ${(originalSize / 1024).toFixed(2)}KB ‚Üí ${(compressedSize / 1024).toFixed(2)}KB (${compressionRatio}% r√©duit)`);

    return {
      compressedFile,
      originalSize,
      compressedSize,
      error: null
    };

  } catch (err) {
    console.error('‚ùå Erreur compression image:', err);
    return {
      compressedFile: null,
      originalSize: file?.size || 0,
      compressedSize: 0,
      error: {
        message: err.message || 'Erreur lors de la compression',
        code: 'COMPRESSION_ERROR'
      }
    };
  }
}

/**
 * Valider les donn√©es du formulaire de signalement
 * 
 * @param {Object} formData - Donn√©es du formulaire
 * @param {string} formData.type - Type de signalement (OBLIGATOIRE)
 * @param {number} formData.latitude - Latitude GPS (OBLIGATOIRE)
 * @param {number} formData.longitude - Longitude GPS (OBLIGATOIRE)
 * @param {string} [formData.description] - Description
 * @param {string} [formData.phone] - T√©l√©phone
 * @param {string} [formData.citizen_name] - Nom du citoyen
 * @param {string} [formData.commune_id] - ID de la commune
 * 
 * @returns {{isValid: boolean, errors: Object}}
 * 
 * @example
 * const validation = validateReportData(formData);
 * if (!validation.isValid) {
 *   console.error('Erreurs de validation:', validation.errors);
 * }
 */
export function validateReportData(formData) {
  const errors = {};

  // 1. Type obligatoire
  if (!formData.type || formData.type.trim() === '') {
    errors.type = 'Le type de signalement est obligatoire';
  }

  // 2. Latitude obligatoire et valide (-90 √† 90)
  if (formData.latitude === null || formData.latitude === undefined) {
    errors.latitude = 'La latitude GPS est obligatoire';
  } else if (typeof formData.latitude !== 'number' || formData.latitude < -90 || formData.latitude > 90) {
    errors.latitude = 'Latitude invalide (doit √™tre entre -90 et 90)';
  }

  // 3. Longitude obligatoire et valide (-180 √† 180)
  if (formData.longitude === null || formData.longitude === undefined) {
    errors.longitude = 'La longitude GPS est obligatoire';
  } else if (typeof formData.longitude !== 'number' || formData.longitude < -180 || formData.longitude > 180) {
    errors.longitude = 'Longitude invalide (doit √™tre entre -180 et 180)';
  }

  // 4. Description optionnelle mais si fournie, max 1000 caract√®res
  if (formData.description && formData.description.length > 1000) {
    errors.description = 'Description trop longue (max 1000 caract√®res)';
  }

  // 5. T√©l√©phone optionnel mais si fourni, format basique (+221...)
  if (formData.phone && formData.phone.trim() !== '') {
    // Format simple : commence par + ou un chiffre, longueur 9-15
    const phoneRegex = /^[\+]?[0-9]{9,15}$/;
    if (!phoneRegex.test(formData.phone.replace(/[\s\-]/g, ''))) {
      errors.phone = 'Format de t√©l√©phone invalide';
    }
  }

  // 6. Nom du citoyen optionnel mais si fourni, max 100 caract√®res
  if (formData.citizen_name && formData.citizen_name.length > 100) {
    errors.citizen_name = 'Nom trop long (max 100 caract√®res)';
  }

  const isValid = Object.keys(errors).length === 0;

  return { isValid, errors };
}

/**
 * Soumettre un signalement complet (upload image + create report)
 * 
 * Orchestration :
 * 1. Valider les donn√©es du formulaire
 * 2. Si image fournie : comprimer ‚Üí uploader
 * 3. Cr√©er le signalement avec l'URL de l'image
 * 4. Retourner le signalement cr√©√©
 * 
 * @param {Object} formData - Donn√©es du formulaire
 * @param {string} formData.type - Type de signalement
 * @param {number} formData.latitude - Latitude GPS
 * @param {number} formData.longitude - Longitude GPS
 * @param {string} [formData.description] - Description
 * @param {File} [formData.imageFile] - Fichier image (optionnel)
 * @param {string} [formData.phone] - T√©l√©phone
 * @param {string} [formData.citizen_name] - Nom du citoyen
 * @param {string} [formData.commune_id] - ID de la commune
 * 
 * @returns {Promise<{report: Object|null, error: Object|null, validationErrors: Object|null}>}
 * 
 * @example
 * const result = await submitReport({
 *   type: 'voirie',
 *   description: 'Nid de poule',
 *   latitude: 14.6928,
 *   longitude: -17.4467,
 *   commune_id: 'uuid-dakar',
 *   imageFile: fileFromInput,
 *   phone: '+221771234567',
 *   citizen_name: 'Amadou Diallo'
 * });
 * 
 * if (result.validationErrors) {
 *   // Erreurs de validation du formulaire
 *   console.error('Erreurs:', result.validationErrors);
 * } else if (result.error) {
 *   // Erreur technique (upload, DB, etc.)
 *   console.error('Erreur:', result.error.message);
 * } else {
 *   // Succ√®s !
 *   console.log('Signalement cr√©√©:', result.report.id);
 * }
 */
export async function submitReport(formData) {
  try {
    console.log('üìù Soumission du signalement en cours...');

    // √âtape 1 : Validation des donn√©es
    const validation = validateReportData(formData);
    if (!validation.isValid) {
      console.error('‚ùå Erreurs de validation:', validation.errors);
      return {
        report: null,
        error: null,
        validationErrors: validation.errors
      };
    }

    // √âtape 2 : Upload de l'image (si fournie)
    let imageUrl = null;
    if (formData.imageFile) {
      console.log('üì∑ Image fournie, compression et upload en cours...');

      // Compression de l'image
      const compressionResult = await compressImage(formData.imageFile);
      if (compressionResult.error) {
        return {
          report: null,
          error: compressionResult.error,
          validationErrors: null
        };
      }

      // Upload de l'image compress√©e
      const uploadResult = await storageApi.uploadReportImage(
        compressionResult.compressedFile,
        null // reportId g√©n√©r√© automatiquement (temp-{timestamp})
      );

      if (uploadResult.error) {
        return {
          report: null,
          error: uploadResult.error,
          validationErrors: null
        };
      }

      imageUrl = uploadResult.url;
      console.log('‚úÖ Image upload√©e:', imageUrl);
    }

    // √âtape 3 : Cr√©ation du signalement
    console.log('üíæ Cr√©ation du signalement dans la base de donn√©es...');
    const reportResult = await reportApi.createReport({
      type: formData.type,
      description: formData.description || null,
      latitude: formData.latitude,
      longitude: formData.longitude,
      commune_id: formData.commune_id || null,
      image_url: imageUrl,
      phone: formData.phone || null,
      citizen_name: formData.citizen_name || null
      // Note : code_suivi reste NULL (pas de tracking pour MVP)
    });

    if (reportResult.error) {
      return {
        report: null,
        error: reportResult.error,
        validationErrors: null
      };
    }

    console.log('‚úÖ Signalement cr√©√© avec succ√®s:', reportResult.data.id);

    return {
      report: reportResult.data,
      error: null,
      validationErrors: null
    };

  } catch (err) {
    console.error('‚ùå Erreur inattendue submitReport:', err);
    return {
      report: null,
      error: {
        message: err.message || 'Une erreur est survenue',
        code: 'UNEXPECTED_ERROR'
      },
      validationErrors: null
    };
  }
}

/**
 * R√©cup√©rer tous les signalements avec filtres
 * (Simple wrapper autour de reportApi pour coh√©rence)
 * 
 * @param {Object} [options] - Options de filtrage
 * @returns {Promise<{data: Array|null, error: Object|null}>}
 */
export async function getAllReports(options = {}) {
  return await reportApi.getAllReports(options);
}

/**
 * R√©cup√©rer un signalement par ID
 * (Simple wrapper autour de reportApi pour coh√©rence)
 * 
 * @param {string} id - UUID du signalement
 * @returns {Promise<{data: Object|null, error: Object|null}>}
 */
export async function getReportById(id) {
  return await reportApi.getReportById(id);
}

/**
 * Calculer les statistiques des signalements d'une commune (AGENT)
 * 
 * @param {string} communeId - UUID de la commune
 * 
 * @returns {Promise<{stats: Object|null, error: Object|null}>}
 * 
 * @example
 * const result = await getAgentStatistics('uuid-dakar');
 * // result.stats = {
 * //   total: 68,
 * //   pending: 12,
 * //   in_progress: 8,
 * //   resolved: 45,
 * //   rejected: 3,
 * //   by_type: { voirie: 20, eclairage: 15, ... }
 * // }
 */
export async function getAgentStatistics(communeId) {
  try {
    if (!communeId) {
      return {
        stats: null,
        error: {
          message: 'ID de la commune requis',
          code: 'MISSING_COMMUNE_ID'
        }
      };
    }

    console.log(`üìä Calcul des statistiques pour la commune: ${communeId}`);

    // R√©cup√©rer TOUS les signalements de la commune (via RLS)
    const { data: reports, error } = await reportApi.getAllReports({
      commune_id: communeId,
      limit: 1000 // Limite haute pour avoir tous les signalements
    });

    if (error) {
      return {
        stats: null,
        error
      };
    }

    // Calcul des statistiques par statut
    const stats = {
      total: reports.length,
      pending: reports.filter(r => r.status === 'pending').length,
      in_progress: reports.filter(r => r.status === 'in_progress').length,
      resolved: reports.filter(r => r.status === 'resolved').length,
      rejected: reports.filter(r => r.status === 'rejected').length,
    };

    // Calcul des statistiques par type (optionnel)
    const byType = {};
    reports.forEach(r => {
      byType[r.type] = (byType[r.type] || 0) + 1;
    });
    stats.by_type = byType;

    // Calcul des statistiques par priorit√© (optionnel)
    const byPriority = {};
    reports.forEach(r => {
      byPriority[r.priority] = (byPriority[r.priority] || 0) + 1;
    });
    stats.by_priority = byPriority;

    console.log(`‚úÖ Statistiques calcul√©es:`, stats);

    return {
      stats,
      error: null
    };

  } catch (err) {
    console.error('‚ùå Erreur calcul statistiques:', err);
    return {
      stats: null,
      error: {
        message: err.message || 'Erreur lors du calcul des statistiques',
        code: 'STATS_ERROR'
      }
    };
  }
}

/**
 * Exporter des signalements en format CSV
 * 
 * @param {Array} reports - Liste des signalements √† exporter
 * @param {string} [filename='signalements.csv'] - Nom du fichier CSV
 * 
 * @returns {string} - Contenu CSV (√† t√©l√©charger via un blob)
 * 
 * @example
 * const reports = await getAllReports({ commune_id: 'uuid-dakar' });
 * const csv = exportToCSV(reports.data);
 * // T√©l√©charger le CSV :
 * const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
 * const link = document.createElement('a');
 * link.href = URL.createObjectURL(blob);
 * link.download = 'signalements-dakar.csv';
 * link.click();
 */
export function exportToCSV(reports) {
  try {
    if (!reports || reports.length === 0) {
      console.warn('‚ö†Ô∏è Aucun signalement √† exporter');
      return '';
    }

    console.log(`üì• Export CSV de ${reports.length} signalements...`);

    // En-t√™tes du CSV
    const headers = [
      'ID',
      'Type',
      'Description',
      'Statut',
      'Priorit√©',
      'Commune',
      'Latitude',
      'Longitude',
      'Citoyen',
      'T√©l√©phone',
      'Date cr√©ation',
      'Date mise √† jour'
    ];

    // Convertir les signalements en lignes CSV
    const rows = reports.map(r => [
      r.id || '',
      r.type || '',
      (r.description || '').replace(/"/g, '""'), // √âchapper les guillemets
      r.status || '',
      r.priority || '',
      r.commune?.name || r.commune_id || '',
      r.latitude || '',
      r.longitude || '',
      (r.citizen_name || '').replace(/"/g, '""'),
      r.phone || '',
      r.created_at ? new Date(r.created_at).toLocaleDateString('fr-FR') : '',
      r.updated_at ? new Date(r.updated_at).toLocaleDateString('fr-FR') : ''
    ]);

    // Construire le CSV
    const csvContent = [
      headers.join(','), // Ligne d'en-t√™tes
      ...rows.map(row => row.map(cell => `"${cell}"`).join(',')) // Lignes de donn√©es
    ].join('\n');

    console.log('‚úÖ CSV g√©n√©r√© avec succ√®s');

    return csvContent;

  } catch (err) {
    console.error('‚ùå Erreur export CSV:', err);
    return '';
  }
}

/**
 * T√©l√©charger un CSV automatiquement (helper function)
 * 
 * @param {Array} reports - Liste des signalements
 * @param {string} [filename='signalements.csv'] - Nom du fichier
 */
export function downloadCSV(reports, filename = 'signalements.csv') {
  const csv = exportToCSV(reports);
  
  if (!csv) {
    console.error('‚ùå Impossible de g√©n√©rer le CSV');
    return;
  }

  // Cr√©er un Blob et d√©clencher le t√©l√©chargement
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  link.click();

  console.log(`‚úÖ T√©l√©chargement lanc√©: ${filename}`);
}

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * ADMIN ANALYTICS
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 */

/**
 * Calculer les analytics globales pour l'admin
 * 
 * @returns {Promise<{analytics: Object|null, error: Object|null}>}
 * 
 * @returns analytics.global_stats - Statistiques globales (total, pending, etc.)
 * @returns analytics.top_communes - Top 5 communes class√©es
 * @returns analytics.by_type - R√©partition par type de signalement
 * @returns analytics.trends - √âvolution sur 30 derniers jours
 * 
 * @example
 * const { analytics, error } = await calculateGlobalAnalytics();
 */
export async function calculateGlobalAnalytics() {
  try {
    console.log('üîÑ Calcul analytics globales...');

    // R√©cup√©rer stats globales
    const { stats: globalStats, error: statsError } = await reportApi.getGlobalStatistics();
    if (statsError) {
      return { analytics: null, error: statsError };
    }

    // R√©cup√©rer top communes
    const { data: topCommunes, error: topError } = await reportApi.getTopCommunes(5);
    if (topError) {
      return { analytics: null, error: topError };
    }

    // R√©cup√©rer TOUS les signalements pour analytics d√©taill√©s
    const { data: allReports, error: reportsError } = await reportApi.getAdminReports({ limit: 10000 });
    if (reportsError) {
      return { analytics: null, error: reportsError };
    }

    // Calculer r√©partition par type
    const byType = {
      road: allReports.filter(r => r.type === 'road').length,
      lighting: allReports.filter(r => r.type === 'lighting').length,
      water: allReports.filter(r => r.type === 'water').length,
      waste: allReports.filter(r => r.type === 'waste').length,
      security: allReports.filter(r => r.type === 'security').length,
      other: allReports.filter(r => r.type === 'other').length,
    };

    // Calculer trends (30 derniers jours)
    const trends = calculateTrends(allReports, 30);

    const analytics = {
      global_stats: globalStats,
      top_communes: topCommunes,
      by_type: byType,
      trends: trends
    };

    console.log('‚úÖ Analytics globales calcul√©es');
    return { analytics, error: null };

  } catch (err) {
    console.error('‚ùå Erreur calcul analytics:', err);
    return {
      analytics: null,
      error: {
        message: err.message || 'Erreur inattendue',
        code: 'UNEXPECTED_ERROR'
      }
    };
  }
}

/**
 * Calculer les trends (√©volution dans le temps)
 * 
 * @param {Array} reports - Tous les signalements
 * @param {number} days - Nombre de jours √† analyser
 * @returns {Array} - Array de points { date, count }
 */
function calculateTrends(reports, days = 30) {
  const now = new Date();
  const trends = [];

  for (let i = days - 1; i >= 0; i--) {
    const targetDate = new Date(now);
    targetDate.setDate(targetDate.getDate() - i);
    targetDate.setHours(0, 0, 0, 0);

    const nextDate = new Date(targetDate);
    nextDate.setDate(nextDate.getDate() + 1);

    const count = reports.filter(r => {
      const createdAt = new Date(r.created_at);
      return createdAt >= targetDate && createdAt < nextDate;
    }).length;

    trends.push({
      date: targetDate.toISOString().split('T')[0], // Format: 2025-10-25
      count: count
    });
  }

  return trends;
}

export default {
  compressImage,
  validateReportData,
  submitReport,
  getAllReports,
  getReportById,
  getAgentStatistics,
  exportToCSV,
  downloadCSV,
  calculateGlobalAnalytics,
  COMPRESSION_OPTIONS
};

