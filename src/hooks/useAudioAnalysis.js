// @generated by Cursor AI (Claude) — verified by Kevin

import { useState, useCallback, useRef } from 'react';
import { GoogleGenAI } from '@google/genai';
import geminiConfig from '@/config/gemini';
import { parseFieldValue } from '@/utils/voiceDataParser';

const VALID_CATEGORIES = [
  'voirie',
  'eclairage',
  'eau',
  'dechets',
  'securite',
  'espaces_verts',
  'assainissement',
  'transport',
  'autre',
];

const CATEGORY_KEYWORDS = [
  { value: 'voirie', keywords: ['route', 'chaussée', 'nid de poule', 'trou', 'pavage', 'pont', 'trottoir', 'voirie'] },
  { value: 'eclairage', keywords: ['lampadaire', 'éclairage', 'ampoule', 'luminaire', 'lanterne', 'lumière', 'éteint'] },
  { value: 'eau', keywords: ['eau', 'fuite', 'canalisation', 'robinet', 'inondation', 'pluie', 'tuyau', 'puits'] },
  { value: 'dechets', keywords: ['déchets', 'ordures', 'poubelle', 'saleté', 'salubrité', 'dépotoir'] },
  { value: 'securite', keywords: ['insécurité', 'agression', 'violence', 'police', 'crime', 'danger', 'sécurité', 'vol'] },
  { value: 'espaces_verts', keywords: ['parc', 'arbre', 'jardin', 'espaces verts', 'fleur', 'pelouse'] },
  { value: 'assainissement', keywords: ['égout', 'assainissement', 'caniveau', 'odorant', 'eaux usées', 'fosse'] },
  { value: 'transport', keywords: ['bus', 'transport', 'station', 'gare', 'taxi', 'embouteillage'] },
  { value: 'autre', keywords: [] },
];

const SEVERITY_KEYWORDS = {
  high: ['urgent', 'danger', 'grave', 'blessé', 'blessure', 'risque', 'immédiat'],
  medium: ['important', 'problème', 'bloqué', 'cassé'],
  low: ['petit', 'léger', 'mineur'],
};

function detectCategory(text) {
  if (!text || typeof text !== 'string') {
    return { value: 'autre', confidence: 0, matches: [] };
  }

  const normalized = text.toLowerCase();
  let best = { value: 'autre', confidence: 0, matches: [] };

  CATEGORY_KEYWORDS.forEach((category) => {
    if (category.value === 'autre') {
      return;
    }
    const matches = category.keywords.filter((keyword) => normalized.includes(keyword));
    if (matches.length > 0) {
      const confidence = matches.length / category.keywords.length;
      if (confidence > best.confidence) {
        best = {
          value: category.value,
          confidence,
          matches,
        };
      }
    }
  });

  return best;
}

function detectSeverity(text) {
  if (!text || typeof text !== 'string') {
    return 'medium';
  }

  const normalized = text.toLowerCase();

  if (SEVERITY_KEYWORDS.high.some((keyword) => normalized.includes(keyword))) {
    return 'high';
  }
  if (SEVERITY_KEYWORDS.medium.some((keyword) => normalized.includes(keyword))) {
    return 'medium';
  }
  if (SEVERITY_KEYWORDS.low.some((keyword) => normalized.includes(keyword))) {
    return 'low';
  }

  return 'medium';
}

async function blobToBase64(blob) {
  const buffer = await blob.arrayBuffer();
  let binary = '';
  const bytes = new Uint8Array(buffer);
  const chunkSize = 0x8000;

  for (let i = 0; i < bytes.length; i += chunkSize) {
    const chunk = bytes.subarray(i, i + chunkSize);
    binary += String.fromCharCode.apply(null, chunk);
  }

  return btoa(binary);
}

function safeJsonParse(text) {
  if (!text) {
    return null;
  }

  const trimmed = text.trim();
  const jsonMatch = trimmed.match(/\{[\s\S]*\}/);
  const jsonString = jsonMatch ? jsonMatch[0] : trimmed;

  try {
    return JSON.parse(jsonString);
  } catch (err) {
    console.warn('⚠️ Impossible de parser la réponse Gemini en JSON:', err, jsonString);
    return null;
  }
}

export function useAudioAnalysis(options = {}) {
  const {
    language = 'fr',
    communes = [],
  } = options;

  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [error, setError] = useState(null);
  const [result, setResult] = useState(null);
  const [isSupported] = useState(Boolean(geminiConfig.enabled && geminiConfig.apiKey));
  const geminiClientRef = useRef(null);

  const ensureClient = useCallback(() => {
    if (!isSupported) {
      return null;
    }
    if (!geminiClientRef.current) {
      try {
        geminiClientRef.current = new GoogleGenAI({ apiKey: geminiConfig.apiKey });
      } catch (err) {
        console.error(' Erreur initialisation Gemini STT:', err);
        return null;
      }
    }
    return geminiClientRef.current;
  }, [isSupported]);

  const resetAnalysis = useCallback(() => {
    setIsAnalyzing(false);
    setError(null);
    setResult(null);
  }, []);

  const analyzeAudio = useCallback(
    async ({ audioBlob, metadata = {} }) => {
      if (!audioBlob) {
        const noBlobError = {
          code: 'NO_AUDIO',
          message: 'Aucun audio fourni pour l’analyse',
        };
        setError(noBlobError);
        return { success: false, error: noBlobError };
      }

      const client = ensureClient();
      if (!client) {
        const notSupportedError = {
          code: 'NOT_SUPPORTED',
          message: 'Gemini STT n’est pas disponible. Configurez VITE_GEMINI_API_KEY.',
        };
        setError(notSupportedError);
        return { success: false, error: notSupportedError };
      }

      try {
        setIsAnalyzing(true);
        setError(null);

        const base64Audio = await blobToBase64(audioBlob);
        const prompt = `Tu es un agent qui aide les citoyens à signaler des incidents urbains (voirie, éclairage, eau, déchets, sécurité, espaces verts, assainissement, transport ou autre).

Analyse l'audio fourni (langue principale: ${language}) et retourne STRICTEMENT un JSON avec la structure :
{
  "transcription": "transcription fidèle en ${language}",
  "summary": "résumé très court (max 20 mots)",
  "keywords": ["mot1","mot2"],
  "category": "voirie|eclairage|eau|dechets|securite|espaces_verts|assainissement|transport|autre",
  "severity": "low|medium|high",
  "actions": ["suggestion optionnelle"],
  "confidence": 0.0-1.0
}

Ne renvoie aucune explication autour du JSON.`;

        const response = await client.models.generateContent({
          model: geminiConfig.model,
          contents: [
            {
              role: 'user',
              parts: [
                {
                  inlineData: {
                    mimeType: audioBlob.type || 'audio/webm',
                    data: base64Audio,
                  },
                },
                { text: prompt },
              ],
            },
          ],
        });

        const textResponse = response.candidates?.[0]?.content?.parts?.map((part) => part.text).join('\n');
        const parsed = safeJsonParse(textResponse) || {};
        const transcription = parsed.transcription?.trim() || '';
        const fallbackCategory = detectCategory(transcription);

        const resolvedCategory = VALID_CATEGORIES.includes(parsed.category)
          ? parsed.category
          : fallbackCategory.value;

        const severity = parsed.severity || detectSeverity(transcription);
        const keywords = Array.from(new Set([...(parsed.keywords || []), ...(fallbackCategory.matches || [])]));
        const summary = parsed.summary || transcription.slice(0, 120);
        const confidence = typeof parsed.confidence === 'number' ? parsed.confidence : fallbackCategory.confidence || 0.4;

        const [address, phone, email, communeId] = await Promise.all([
          parseFieldValue('address', transcription),
          parseFieldValue('phone', transcription),
          parseFieldValue('email', transcription),
          parseFieldValue('commune_id', transcription, communes),
        ]);

        const structuredFields = {
          address,
          phone,
          email,
          commune_id: communeId,
        };

        const analysisResult = {
          transcription,
          summary,
          keywords,
          category: resolvedCategory,
          severity,
          confidence,
          actions: parsed.actions || [],
          structuredFields,
          metadata,
        };

        setResult(analysisResult);
        setIsAnalyzing(false);

        return {
          success: true,
          data: analysisResult,
        };
      } catch (err) {
        console.error('❌ Erreur analyse audio Gemini:', err);
        const analysisError = {
          code: 'ANALYSIS_ERROR',
          message: err.message || 'Impossible d’analyser l’audio',
          originalError: err,
        };
        setError(analysisError);
        setIsAnalyzing(false);
        return { success: false, error: analysisError };
      }
    },
    [communes, ensureClient, language]
  );

  return {
    isSupported,
    isAnalyzing,
    error,
    result,
    analyzeAudio,
    resetAnalysis,
  };
}

export default useAudioAnalysis;


