// @generated by Cursor AI (Claude) — verified by Kevin

import { useState, useEffect, useCallback, useRef } from 'react';
import useGeminiTextToSpeech from './useGeminiTextToSpeech'; // Utiliser Gemini TTS au lieu de Web Speech API
import useTextToSpeech from './useTextToSpeech'; // Fallback vers Web Speech API
import useSpeechRecognition from './useSpeechRecognition';

/**
 * Custom Hook pour gérer le flux d'inscription vocale
 * 
 * Orchestre la conversation entre l'agent IA et l'utilisateur :
 * - Pose les questions via synthèse vocale
 * - Écoute les réponses via reconnaissance vocale
 * - Valide et stocke les données collectées
 * - Gère la navigation entre les questions
 * - Gère les erreurs et retry
 * 
 * @param {Array} questions - Liste des questions à poser (voir voiceSignupQuestions.js)
 * @param {Object} [options] - Options du hook
 * @param {string} [options.language='fr'] - Langue de la conversation
 * @param {number} [options.maxRetries=2] - Nombre maximum de tentatives par question
 * @param {Function} [options.onComplete] - Callback appelé quand toutes les questions sont complétées
 * 
 * @returns {Object} État et fonctions du flux
 * @property {number} currentStep - Index de la question actuelle
 * @property {Object} collectedData - Données collectées jusqu'à présent
 * @property {boolean} isAsking - true si l'agent est en train de parler
 * @property {boolean} isListening - true si on écoute la réponse
 * @property {boolean} isProcessing - true si on traite une réponse
 * @property {boolean} isComplete - true si toutes les questions sont complétées
 * @property {Object|null} error - Erreur éventuelle
 * @property {Function} start - Démarrer le flux
 * @property {Function} nextQuestion - Passer à la question suivante
 * @property {Function} previousQuestion - Revenir à la question précédente
 * @property {Function} retryCurrentQuestion - Réessayer la question actuelle
 * @property {Function} updateData - Mettre à jour une donnée collectée
 * @property {Function} reset - Réinitialiser le flux
 * 
 * @example
 * const { start, currentStep, collectedData, isAsking, isListening, isComplete } = useVoiceSignupFlow(questions);
 * 
 * // Démarrer le flux
 * start();
 * 
 * // Vérifier si terminé
 * if (isComplete) {
 *   console.log('Données collectées:', collectedData);
 * }
 */
export function useVoiceSignupFlow(questions = [], options = {}) {
  const {
    language = 'fr',
    maxRetries = 2,
    onComplete = null,
  } = options;

  // Hooks de base - Utiliser Gemini TTS pour une meilleure qualité vocale
  // Fallback vers Web Speech API si Gemini n'est pas disponible
  const geminiTTS = useGeminiTextToSpeech({ 
    language: language === 'fr' ? 'fr-FR' : 'wo-SN',
    voiceName: 'Kore', // Voix professionnelle et claire
  });
  
  // Fallback vers Web Speech API si Gemini n'est pas disponible
  const webTTS = useTextToSpeech({ language: language === 'fr' ? 'fr-FR' : 'wo-SN' });
  
  // Utiliser Gemini si disponible, sinon Web Speech API
  const { speak, stop: stopSpeaking, isSpeaking, isGenerating = false, error: ttsError } = geminiTTS.isSupported 
    ? geminiTTS 
    : webTTS;
  
  // Logger l'état
  useEffect(() => {
    if (geminiTTS.isSupported) {
      console.log('✅ Utilisation de Gemini TTS');
    } else {
      console.warn('⚠️ Gemini TTS non disponible, utilisation de Web Speech API:', geminiTTS.error);
    }
  }, [geminiTTS.isSupported, geminiTTS.error]);
  const {
    startListening,
    stopListening,
    transcript,
    isListening,
    error: recognitionError,
    clearTranscript,
  } = useSpeechRecognition({ language: language === 'fr' ? 'fr-FR' : 'wo-SN', continuous: false, interimResults: false });

  // État du flux
  const [currentStep, setCurrentStep] = useState(0);
  const [collectedData, setCollectedData] = useState({});
  const [isProcessing, setIsProcessing] = useState(false);
  const [error, setError] = useState(null);
  const [retryCount, setRetryCount] = useState(0);
  const [isStarted, setIsStarted] = useState(false);
  const [showQuestionText, setShowQuestionText] = useState(false); // Contrôle l'affichage du texte de la question

  const onCompleteRef = useRef(onComplete);
  const currentQuestionRef = useRef(null);
  const processedTranscriptRef = useRef(null); // Pour éviter de traiter le même transcript plusieurs fois
  const isProcessingRef = useRef(false); // Pour éviter les appels multiples
  const askCurrentQuestionRef = useRef(null); // Ref pour éviter les dépendances circulaires
  const nextQuestionRef = useRef(null); // Ref pour éviter les dépendances circulaires

  // Mettre à jour la référence du callback
  useEffect(() => {
    onCompleteRef.current = onComplete;
  }, [onComplete]);

  /**
   * Obtenir la question actuelle
   */
  const getCurrentQuestion = useCallback(() => {
    if (questions.length === 0 || currentStep >= questions.length) {
      return null;
    }
    return questions[currentStep];
  }, [questions, currentStep]);

  /**
   * Mettre à jour une donnée collectée
   * 
   * @param {string} key - Clé de la donnée
   * @param {any} value - Valeur de la donnée
   */
  const updateData = useCallback((key, value) => {
    setCollectedData(prev => ({
      ...prev,
      [key]: value,
    }));
  }, []);

  /**
   * Valider une réponse
   * 
   * @param {string} questionId - ID de la question
   * @param {any} value - Valeur à valider
   * @returns {Object} { valid: boolean, error?: string }
   */
  const validateAnswer = useCallback((questionId, value) => {
    const question = questions.find(q => q.id === questionId);
    if (!question) {
      return { valid: false, error: 'Question introuvable' };
    }

    if (question.validation) {
      const isValid = question.validation(value);
      if (!isValid) {
        return {
          valid: false,
          error: question.errorMessage || 'Réponse invalide',
        };
      }
    }

    return { valid: true };
  }, [questions]);

  /**
   * Traiter une réponse
   * 
   * @param {string} rawTranscript - Texte brut transcrit
   */
  const processAnswer = useCallback(async (rawTranscript) => {
    if (!rawTranscript || rawTranscript.trim() === '') {
      return;
    }

    // Éviter de traiter le même transcript plusieurs fois
    if (processedTranscriptRef.current === rawTranscript || isProcessingRef.current) {
      return;
    }

    const question = getCurrentQuestion();
    if (!question) {
      return;
    }

    // Marquer comme en cours de traitement
    isProcessingRef.current = true;
    processedTranscriptRef.current = rawTranscript;
    setIsProcessing(true);
    setError(null);
    
    // Arrêter l'écoute immédiatement pour éviter les doubles traitements
    stopListening();

    try {
      // Parser la réponse si un parser est fourni
      let parsedValue = rawTranscript.trim();
      if (question.parser) {
        // Le parser peut être une fonction async qui prend le texte et retourne la valeur
        // Pour commune_id, le parser a déjà accès aux communes via closure
        parsedValue = await question.parser(rawTranscript);
      }

      // Valider la réponse
      const validation = validateAnswer(question.id, parsedValue);
      if (!validation.valid) {
        setError(validation.error);
        setRetryCount(prev => prev + 1);

        // Si on n'a pas atteint le max de retry, réessayer
        if (retryCount < maxRetries) {
          // Nettoyer le transcript pour permettre une nouvelle réponse
          clearTranscript();
          processedTranscriptRef.current = null;
          setIsProcessing(false);
          isProcessingRef.current = false;
          
          // Attendre un peu avant de réessayer
          setTimeout(() => {
            if (askCurrentQuestionRef.current) {
              askCurrentQuestionRef.current();
            }
          }, 1000);
        } else {
          // Trop de tentatives : attendre l'action de l'utilisateur
          setError({
            code: 'RETRY_LIMIT',
            message: null,
          });
          clearTranscript();
          processedTranscriptRef.current = null;
          setIsProcessing(false);
          isProcessingRef.current = false;
        }
        return;
      }

      // Réponse valide : stocker la donnée
      updateData(question.id, parsedValue);
      setRetryCount(0);
      
      // Nettoyer immédiatement le transcript pour éviter les traitements multiples
      clearTranscript();
      processedTranscriptRef.current = null;

      // Passer à la question suivante
      setTimeout(() => {
        isProcessingRef.current = false;
        if (nextQuestionRef.current) {
          nextQuestionRef.current();
        }
      }, 500);

    } catch (err) {
      console.error('❌ Erreur traitement réponse:', err);
      setError('Erreur lors du traitement de la réponse. Veuillez réessayer.');
      setIsProcessing(false);
      isProcessingRef.current = false;
      processedTranscriptRef.current = null;
    }
  }, [getCurrentQuestion, validateAnswer, updateData, retryCount, maxRetries, clearTranscript, stopListening]);

  /**
   * Poser la question actuelle
   */
  const askCurrentQuestion = useCallback(() => {
    const question = getCurrentQuestion();
    if (!question) {
      return;
    }

    currentQuestionRef.current = question;

    // Construire le texte de la question (avec interpolation si nécessaire)
    let questionText = question.question;
    if (typeof questionText === 'function') {
      questionText = questionText(collectedData);
    } else {
      // Interpoler les variables dans le texte (ex: {firstName})
      questionText = questionText.replace(/\{(\w+)\}/g, (match, key) => {
        return collectedData[key] || match;
      });
    }

    // Cacher le texte de la question jusqu'à ce que la synthèse vocale commence
    setShowQuestionText(false);

    // Parler la question avec callbacks
    speak(
      questionText, 
      {}, 
      () => {
        // Quand la question est terminée, démarrer l'écoute
        setTimeout(() => {
          startListening();
        }, 300);
      },
      () => {
        // Quand la synthèse vocale commence, afficher le texte
        setShowQuestionText(true);
      }
    );
  }, [getCurrentQuestion, collectedData, speak, startListening, setShowQuestionText]);
  
  // Mettre à jour la ref
  useEffect(() => {
    askCurrentQuestionRef.current = askCurrentQuestion;
  }, [askCurrentQuestion]);

  /**
   * Passer à la question suivante
   */
  const nextQuestion = useCallback(() => {
    if (currentStep >= questions.length - 1) {
      // Toutes les questions sont complétées
      setIsProcessing(false);
      setShowQuestionText(false);
      if (onCompleteRef.current) {
        onCompleteRef.current(collectedData);
      }
      return;
    }

    // Cacher le texte avant de passer à la question suivante
    setShowQuestionText(false);
    setCurrentStep(prev => prev + 1);
    setRetryCount(0);
    setError(null);
    setIsProcessing(false);

    // Poser la nouvelle question après un court délai
    setTimeout(() => {
      if (askCurrentQuestionRef.current) {
        askCurrentQuestionRef.current();
      }
    }, 500);
  }, [currentStep, questions.length]);
  
  // Mettre à jour la ref
  useEffect(() => {
    nextQuestionRef.current = nextQuestion;
  }, [nextQuestion]);

  /**
   * Revenir à la question précédente
   */
  const previousQuestion = useCallback(() => {
    if (currentStep <= 0) {
      return;
    }

    stopSpeaking();
    stopListening();
    clearTranscript();

    setCurrentStep(prev => prev - 1);
    setRetryCount(0);
    setError(null);
    setIsProcessing(false);

    // Poser la question précédente
    setTimeout(() => {
      if (askCurrentQuestionRef.current) {
        askCurrentQuestionRef.current();
      }
    }, 300);
  }, [currentStep, stopSpeaking, stopListening, clearTranscript]);

  /**
   * Réessayer la question actuelle
   */
  const retryCurrentQuestion = useCallback(() => {
    stopSpeaking();
    stopListening();
    clearTranscript();
    processedTranscriptRef.current = null;
    isProcessingRef.current = false;
    setError(null);
    setRetryCount(0);
    setIsProcessing(false);

    setTimeout(() => {
      if (askCurrentQuestionRef.current) {
        askCurrentQuestionRef.current();
      }
    }, 300);
  }, [stopSpeaking, stopListening, clearTranscript]);

  /**
   * Démarrer le flux
   */
  const start = useCallback(() => {
    if (questions.length === 0) {
      setError('Aucune question définie');
      return;
    }

    setIsStarted(true);
    setCurrentStep(0);
    setCollectedData({});
    setRetryCount(0);
    setError(null);
    setIsProcessing(false);
    setShowQuestionText(false);
    clearTranscript();
    processedTranscriptRef.current = null;
    isProcessingRef.current = false;

    // Poser la première question après un court délai pour s'assurer que les refs sont initialisées
    setTimeout(() => {
      if (askCurrentQuestionRef.current) {
        askCurrentQuestionRef.current();
      } else {
        // Fallback : utiliser directement askCurrentQuestion si la ref n'est pas encore prête
        const question = questions[0];
        if (question) {
          let questionText = typeof question.question === 'function' 
            ? question.question({})
            : question.question;
          setShowQuestionText(false);
          speak(
            questionText,
            {},
            () => {
              setTimeout(() => {
                startListening();
              }, 300);
            },
            () => {
              setShowQuestionText(true);
            }
          );
        }
      }
    }, 500);
  }, [questions, clearTranscript, speak, startListening]);

  /**
   * Réinitialiser le flux
   */
  const reset = useCallback(() => {
    stopSpeaking();
    stopListening();
    clearTranscript();
    setIsStarted(false);
    setCurrentStep(0);
    setCollectedData({});
    setRetryCount(0);
    setError(null);
    setIsProcessing(false);
    setShowQuestionText(false);
    processedTranscriptRef.current = null;
    isProcessingRef.current = false;
  }, [stopSpeaking, stopListening, clearTranscript]);

  /**
   * Écouter les changements de transcript
   */
  useEffect(() => {
    // Ne traiter que si :
    // - Il y a un transcript
    // - On n'écoute plus
    // - Le flux a démarré
    // - On n'est pas déjà en train de traiter
    // - Le transcript n'a pas déjà été traité
    if (
      transcript && 
      transcript.trim() !== '' &&
      !isListening && 
      isStarted && 
      !isProcessing &&
      !isProcessingRef.current &&
      processedTranscriptRef.current !== transcript
    ) {
      // L'utilisateur a fini de parler, traiter la réponse
      processAnswer(transcript);
    }
  }, [transcript, isListening, isStarted, isProcessing, processAnswer]);

  /**
   * Gérer les erreurs de reconnaissance
   */
  useEffect(() => {
    if (recognitionError && isStarted) {
      setError(recognitionError.message || 'Erreur de reconnaissance vocale');
      
      // Si erreur de permission, arrêter le flux
      if (recognitionError.code === 'PERMISSION_DENIED') {
        setIsStarted(false);
      }
    }
  }, [recognitionError, isStarted]);

  const isComplete = currentStep >= questions.length && Object.keys(collectedData).length > 0;
  const isAsking = isSpeaking || isGenerating; // Inclure la génération dans "isAsking"

  return {
    // État
    currentStep,
    collectedData,
    isAsking,
    isGenerating, // Exposer l'état de génération
    isListening,
    isProcessing,
    isComplete,
    isStarted,
    showQuestionText, // Nouvel état pour contrôler l'affichage du texte
    error: error || recognitionError || ttsError,
    
    // Fonctions
    start,
    nextQuestion,
    previousQuestion,
    retryCurrentQuestion,
    updateData,
    reset,
    
    // Utilitaires
    getCurrentQuestion,
    currentQuestion: getCurrentQuestion(),
    totalSteps: questions.length,
  };
}

export default useVoiceSignupFlow;

