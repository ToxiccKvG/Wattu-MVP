// @generated by Cursor AI (Claude) â€” verified by Kevin

import { useCallback, useEffect, useRef, useState } from 'react';

/**
 * Hook d'enregistrement audio avec MediaRecorder.
 * - GÃ¨re les permissions micro
 * - Limite automatique (30s par dÃ©faut)
 * - Expose le Blob/audioUrl pour upload
 * - Fournit un timer + Ã©tats d'erreur
 */
export function useAudioRecording(options = {}) {
  const {
    maxDuration = 30, // secondes
    mimeType = 'audio/webm;codecs=opus',
    channelCount = 1,
    sampleRate = 48000,
  } = options;

  const mediaRecorderRef = useRef(null);
  const streamRef = useRef(null);
  const chunksRef = useRef([]);
  const timerRef = useRef(null);

  const [isSupported, setIsSupported] = useState(false);
  const [permission, setPermission] = useState('prompt');
  const [isRequestingPermission, setIsRequestingPermission] = useState(false);
  const [isRecording, setIsRecording] = useState(false);
  const [duration, setDuration] = useState(0);
  const [audioBlob, setAudioBlob] = useState(null);
  const [audioUrl, setAudioUrl] = useState(null);
  const [error, setError] = useState(null);

  /**
   * VÃ©rifie la disponibilitÃ© des APIs requises
   */
  useEffect(() => {
    const supported =
      typeof window !== 'undefined' &&
      navigator?.mediaDevices?.getUserMedia &&
      typeof window.MediaRecorder !== 'undefined';

    setIsSupported(Boolean(supported));

    if (!supported) {
      setError({
        code: 'NOT_SUPPORTED',
        message:
          'Lâ€™enregistrement audio nâ€™est pas supportÃ© par ce navigateur. Veuillez utiliser une version rÃ©cente de Chrome ou Safari.',
      });
    }
  }, []);

  /**
   * Demande la permission micro (ou renvoie l'Ã©tat actuel)
   */
  const requestPermission = useCallback(async () => {
    if (!isSupported) {
      return 'denied';
    }

    if (!navigator.permissions) {
      // Safari iOS ne supporte pas lâ€™API Permissions => demander directement
      try {
        setIsRequestingPermission(true);
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        stream.getTracks().forEach((track) => track.stop());
        setPermission('granted');
        return 'granted';
      } catch (err) {
        setPermission('denied');
        setError({
          code: 'PERMISSION_DENIED',
          message:
            'Permission micro refusÃ©e. Autorisez lâ€™accÃ¨s au micro dans les rÃ©glages de votre navigateur.',
          originalError: err,
        });
        return 'denied';
      } finally {
        setIsRequestingPermission(false);
      }
    }

    try {
      const status = await navigator.permissions.query({ name: 'microphone' });
      setPermission(status.state);

      if (status.state === 'prompt') {
        setIsRequestingPermission(true);
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          stream.getTracks().forEach((track) => track.stop());
          setPermission('granted');
          return 'granted';
        } catch (err) {
          setPermission('denied');
          setError({
            code: 'PERMISSION_DENIED',
            message:
              'Permission micro refusÃ©e. Autorisez lâ€™accÃ¨s au micro dans les rÃ©glages de votre navigateur.',
            originalError: err,
          });
          return 'denied';
        } finally {
          setIsRequestingPermission(false);
        }
      }

      return status.state;
    } catch (err) {
      console.warn('âš ï¸ Impossible de vÃ©rifier la permission micro:', err);
      return 'prompt';
    }
  }, [isSupported]);

  /**
   * Nettoyer flux/timer/audioURL
   */
  const cleanup = useCallback(() => {
    if (timerRef.current) {
      clearInterval(timerRef.current);
      timerRef.current = null;
    }

    if (mediaRecorderRef.current) {
      mediaRecorderRef.current.ondataavailable = null;
      mediaRecorderRef.current.onstop = null;
      mediaRecorderRef.current.onerror = null;
      mediaRecorderRef.current = null;
    }

    if (streamRef.current) {
      streamRef.current.getTracks().forEach((track) => track.stop());
      streamRef.current = null;
    }

    chunksRef.current = [];
  }, []);

  /**
   * Stopper timer + enregistrer audio
   */
  const finalizeRecording = useCallback(() => {
    if (chunksRef.current.length === 0) {
      return;
    }

    const blob = new Blob(chunksRef.current, { type: mimeType });
    const url = URL.createObjectURL(blob);
    setAudioBlob(blob);
    setAudioUrl(url);
  }, [mimeType]);

  /**
   * Lance lâ€™enregistrement
   */
  const startRecording = useCallback(
    async (overrides = {}) => {
      if (!isSupported) {
        setError({
          code: 'NOT_SUPPORTED',
          message: 'Votre navigateur ne supporte pas lâ€™enregistrement audio',
        });
        return { success: false };
      }

      if (isRecording) {
        return { success: true };
      }

      try {
        setError(null);
        const permissionState = await requestPermission();
        if (permissionState !== 'granted') {
          return { success: false, error: 'PERMISSION_DENIED' };
        }

        setAudioBlob(null);
        setAudioUrl(null);
        setDuration(0);

        const constraints = {
          audio: {
            channelCount,
            sampleRate,
            noiseSuppression: true,
            echoCancellation: true,
            ...overrides.constraints,
          },
        };

        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        streamRef.current = stream;

        const recorder = new MediaRecorder(stream, { mimeType, ...overrides.recorderOptions });
        mediaRecorderRef.current = recorder;

        recorder.ondataavailable = (event) => {
          if (event.data && event.data.size > 0) {
            chunksRef.current.push(event.data);
          }
        };

        recorder.onerror = (recError) => {
          console.error('âŒ MediaRecorder error:', recError);
          setError({
            code: 'RECORDER_ERROR',
            message: 'Une erreur est survenue pendant lâ€™enregistrement audio.',
            originalError: recError,
          });
          stopRecording();
        };

        recorder.onstop = () => {
          finalizeRecording();
          cleanup();
          setIsRecording(false);
        };

        recorder.start(1000); // collecter en chunks toutes les secondes
        setIsRecording(true);

        timerRef.current = setInterval(() => {
          setDuration((prev) => {
            const next = prev + 1;
            if (next >= maxDuration) {
              stopRecording();
            }
            return next;
          });
        }, 1000);

        console.log('ðŸŽ™ï¸ Enregistrement dÃ©marrÃ©');
        return { success: true };
      } catch (err) {
        console.error('âŒ startRecording error:', err);
        setError({
          code: 'RECORDER_START_ERROR',
          message: 'Impossible de dÃ©marrer lâ€™enregistrement audio. VÃ©rifiez vos permissions.',
          originalError: err,
        });
        cleanup();
        setIsRecording(false);
        return { success: false, error: err };
      }
    },
    [channelCount, cleanup, finalizeRecording, isRecording, isSupported, maxDuration, mimeType, requestPermission, sampleRate]
  );

  /**
   * Stop manuel
   */
  const stopRecording = useCallback(() => {
    if (!mediaRecorderRef.current) {
      return;
    }

    if (mediaRecorderRef.current.state !== 'inactive') {
      mediaRecorderRef.current.stop();
    }

    if (timerRef.current) {
      clearInterval(timerRef.current);
      timerRef.current = null;
    }

    if (streamRef.current) {
      streamRef.current.getTracks().forEach((track) => track.stop());
      streamRef.current = null;
    }

    setIsRecording(false);
    console.log('ðŸ›‘ Enregistrement arrÃªtÃ©');
  }, []);

  /**
   * RÃ©initialisation complÃ¨te
   */
  const resetRecording = useCallback(() => {
    stopRecording();
    cleanup();
    setDuration(0);
    setAudioBlob(null);
    setAudioUrl(null);
    setError(null);
    setPermission('prompt');
  }, [cleanup, stopRecording]);

  /**
   * Cleanup global sur unmount
   */
  useEffect(() => {
    return () => {
      if (audioUrl) {
        URL.revokeObjectURL(audioUrl);
      }
      cleanup();
    };
  }, [audioUrl, cleanup]);

  return {
    isSupported,
    permission,
    isRequestingPermission,
    isRecording,
    duration,
    maxDuration,
    audioBlob,
    audioUrl,
    error,
    startRecording,
    stopRecording,
    resetRecording,
    requestPermission,
  };
}

export default useAudioRecording;


