// @generated by Cursor AI (Claude) ‚Äî verified by Kevin

import { useCallback, useEffect, useRef, useState } from 'react';

/**
 * Hook d'enregistrement audio avec MediaRecorder.
 * - G√®re les permissions micro
 * - Limite automatique (30s par d√©faut)
 * - Expose le Blob/audioUrl pour upload
 * - Fournit un timer + √©tats d'erreur
 */
export function useAudioRecording(options = {}) {
  const {
    maxDuration = 30, // secondes
    mimeType = 'audio/webm;codecs=opus',
    channelCount = 1,
    sampleRate = 48000,
  } = options;

  const mediaRecorderRef = useRef(null);
  const streamRef = useRef(null);
  const chunksRef = useRef([]);
  const timerRef = useRef(null);
  const analyserRef = useRef(null);
  const audioContextRef = useRef(null);
  const animationFrameRef = useRef(null);

  const [isSupported, setIsSupported] = useState(false);
  const [permission, setPermission] = useState('prompt');
  const [isRequestingPermission, setIsRequestingPermission] = useState(false);
  const [isRecording, setIsRecording] = useState(false);
  const [duration, setDuration] = useState(0);
  const [audioBlob, setAudioBlob] = useState(null);
  const [audioUrl, setAudioUrl] = useState(null);
  const [error, setError] = useState(null);
  const [volume, setVolume] = useState(0); // Volume entre 0 et 1

  /**
   * V√©rifie la disponibilit√© des APIs requises
   */
  useEffect(() => {
    const supported =
      typeof window !== 'undefined' &&
      navigator?.mediaDevices?.getUserMedia &&
      typeof window.MediaRecorder !== 'undefined';

    setIsSupported(Boolean(supported));

    if (!supported) {
      setError({
        code: 'NOT_SUPPORTED',
        message:
          'L‚Äôenregistrement audio n‚Äôest pas support√© par ce navigateur. Veuillez utiliser une version r√©cente de Chrome ou Safari.',
      });
    }
  }, []);

  /**
   * Demande la permission micro (ou renvoie l'√©tat actuel)
   */
  const requestPermission = useCallback(async () => {
    if (!isSupported) {
      return 'denied';
    }

    if (!navigator.permissions) {
      // Safari iOS ne supporte pas l‚ÄôAPI Permissions => demander directement
      try {
        setIsRequestingPermission(true);
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        stream.getTracks().forEach((track) => track.stop());
        setPermission('granted');
        return 'granted';
      } catch (err) {
        setPermission('denied');
        setError({
          code: 'PERMISSION_DENIED',
          message:
            'Permission micro refus√©e. Autorisez l‚Äôacc√®s au micro dans les r√©glages de votre navigateur.',
          originalError: err,
        });
        return 'denied';
      } finally {
        setIsRequestingPermission(false);
      }
    }

    try {
      const status = await navigator.permissions.query({ name: 'microphone' });
      setPermission(status.state);

      if (status.state === 'prompt') {
        setIsRequestingPermission(true);
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          stream.getTracks().forEach((track) => track.stop());
          setPermission('granted');
          return 'granted';
        } catch (err) {
          setPermission('denied');
          setError({
            code: 'PERMISSION_DENIED',
            message:
              'Permission micro refus√©e. Autorisez l‚Äôacc√®s au micro dans les r√©glages de votre navigateur.',
            originalError: err,
          });
          return 'denied';
        } finally {
          setIsRequestingPermission(false);
        }
      }

      return status.state;
    } catch (err) {
      console.warn('‚ö†Ô∏è Impossible de v√©rifier la permission micro:', err);
      return 'prompt';
    }
  }, [isSupported]);

  /**
   * Analyser le volume en temps r√©el
   */
  const analyzeVolume = useCallback(() => {
    if (!analyserRef.current) {
      return;
    }

    const dataArray = new Uint8Array(analyserRef.current.frequencyBinCount);
    analyserRef.current.getByteFrequencyData(dataArray);
    
    // Calculer le volume moyen
    const average = dataArray.reduce((sum, value) => sum + value, 0) / dataArray.length;
    const normalizedVolume = Math.min(1, average / 128); // Normaliser entre 0 et 1
    setVolume(normalizedVolume);

    // Continuer l'analyse si on enregistre toujours
    if (analyserRef.current) {
      animationFrameRef.current = requestAnimationFrame(analyzeVolume);
    }
  }, []);

  /**
   * Nettoyer flux/timer/audioURL
   */
  const cleanup = useCallback(() => {
    if (animationFrameRef.current) {
      cancelAnimationFrame(animationFrameRef.current);
      animationFrameRef.current = null;
    }

    if (timerRef.current) {
      clearInterval(timerRef.current);
      timerRef.current = null;
    }

    if (analyserRef.current) {
      analyserRef.current = null;
    }

    if (audioContextRef.current) {
      audioContextRef.current.close().catch(console.error);
      audioContextRef.current = null;
    }

    if (mediaRecorderRef.current) {
      mediaRecorderRef.current.ondataavailable = null;
      mediaRecorderRef.current.onstop = null;
      mediaRecorderRef.current.onerror = null;
      mediaRecorderRef.current = null;
    }

    if (streamRef.current) {
      streamRef.current.getTracks().forEach((track) => track.stop());
      streamRef.current = null;
    }

    chunksRef.current = [];
    setVolume(0);
  }, []);

  /**
   * Stopper timer + enregistrer audio
   */
  const finalizeRecording = useCallback(() => {
    if (chunksRef.current.length === 0) {
      return;
    }

    const blob = new Blob(chunksRef.current, { type: mimeType });
    const url = URL.createObjectURL(blob);
    setAudioBlob(blob);
    setAudioUrl(url);
  }, [mimeType]);

  /**
   * Lance l‚Äôenregistrement
   */
  const startRecording = useCallback(
    async (overrides = {}) => {
      if (!isSupported) {
        setError({
          code: 'NOT_SUPPORTED',
          message: 'Votre navigateur ne supporte pas l‚Äôenregistrement audio',
        });
        return { success: false };
      }

      if (isRecording) {
        return { success: true };
      }

      try {
        setError(null);
        const permissionState = await requestPermission();
        if (permissionState !== 'granted') {
          return { success: false, error: 'PERMISSION_DENIED' };
        }

        setAudioBlob(null);
        setAudioUrl(null);
        setDuration(0);

        const constraints = {
          audio: {
            channelCount,
            sampleRate,
            noiseSuppression: true,
            echoCancellation: true,
            ...overrides.constraints,
          },
        };

        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        streamRef.current = stream;

        // Cr√©er l'analyseur audio pour le volume
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        audioContextRef.current = audioContext;
        const source = audioContext.createMediaStreamSource(stream);
        const analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        analyser.smoothingTimeConstant = 0.8;
        source.connect(analyser);
        analyserRef.current = analyser;

        const recorder = new MediaRecorder(stream, { mimeType, ...overrides.recorderOptions });
        mediaRecorderRef.current = recorder;

        recorder.ondataavailable = (event) => {
          if (event.data && event.data.size > 0) {
            chunksRef.current.push(event.data);
          }
        };

        recorder.onerror = (recError) => {
          console.error('‚ùå MediaRecorder error:', recError);
          setError({
            code: 'RECORDER_ERROR',
            message: 'Une erreur est survenue pendant l‚Äôenregistrement audio.',
            originalError: recError,
          });
          stopRecording();
        };

        recorder.onstop = () => {
          finalizeRecording();
          cleanup();
          setIsRecording(false);
        };

        recorder.start(1000); // collecter en chunks toutes les secondes
        setIsRecording(true);
        setVolume(0);

        // D√©marrer l'analyse du volume
        analyzeVolume();

        timerRef.current = setInterval(() => {
          setDuration((prev) => {
            const next = prev + 1;
            if (next >= maxDuration) {
              stopRecording();
            }
            return next;
          });
        }, 1000);

        console.log('üéôÔ∏è Enregistrement d√©marr√©');
        return { success: true };
      } catch (err) {
        console.error('‚ùå startRecording error:', err);
        setError({
          code: 'RECORDER_START_ERROR',
          message: 'Impossible de d√©marrer l‚Äôenregistrement audio. V√©rifiez vos permissions.',
          originalError: err,
        });
        cleanup();
        setIsRecording(false);
        return { success: false, error: err };
      }
    },
    [channelCount, cleanup, finalizeRecording, isRecording, isSupported, maxDuration, mimeType, requestPermission, sampleRate]
  );

  /**
   * Stop manuel
   */
  const stopRecording = useCallback(() => {
    if (!mediaRecorderRef.current) {
      return;
    }

    if (mediaRecorderRef.current.state !== 'inactive') {
      mediaRecorderRef.current.stop();
    }

    if (timerRef.current) {
      clearInterval(timerRef.current);
      timerRef.current = null;
    }

    if (streamRef.current) {
      streamRef.current.getTracks().forEach((track) => track.stop());
      streamRef.current = null;
    }

    setIsRecording(false);
    console.log('üõë Enregistrement arr√™t√©');
  }, []);

  /**
   * R√©initialisation compl√®te
   */
  const resetRecording = useCallback(() => {
    stopRecording();
    cleanup();
    setDuration(0);
    setAudioBlob(null);
    setAudioUrl(null);
    setError(null);
    setPermission('prompt');
  }, [cleanup, stopRecording]);

  /**
   * Cleanup global sur unmount
   */
  useEffect(() => {
    return () => {
      if (audioUrl) {
        URL.revokeObjectURL(audioUrl);
      }
      cleanup();
    };
  }, [audioUrl, cleanup]);

  return {
    isSupported,
    permission,
    isRequestingPermission,
    isRecording,
    duration,
    maxDuration,
    audioBlob,
    audioUrl,
    error,
    volume, // Volume en temps r√©el (0-1)
    startRecording,
    stopRecording,
    resetRecording,
    requestPermission,
  };
}

export default useAudioRecording;


