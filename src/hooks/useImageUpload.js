// @generated by Cursor AI (Claude) ‚Äî verified by Kevin Mendy
import { useState, useCallback } from 'react';
import * as reportService from '@/services/reportService';

/**
 * Custom Hook pour la gestion d'upload d'images
 * 
 * Fonctionnalit√©s :
 * - S√©lection de fichier image
 * - Preview de l'image avant upload
 * - Compression automatique
 * - Validation (type, taille)
 * - Suppression/R√©initialisation
 * 
 * @returns {Object} √âtat et fonctions d'upload
 * @property {File|null} imageFile - Fichier image s√©lectionn√©
 * @property {string|null} imagePreview - URL de preview de l'image
 * @property {boolean} isCompressing - true si compression en cours
 * @property {Object|null} error - Erreur √©ventuelle
 * @property {function} selectImage - S√©lectionner une image depuis un input
 * @property {function} removeImage - Supprimer l'image s√©lectionn√©e
 * @property {function} resetState - R√©initialiser tout l'√©tat
 * 
 * @example
 * const { imageFile, imagePreview, error, selectImage, removeImage } = useImageUpload();
 * 
 * <input type="file" accept="image/*" onChange={selectImage} />
 * {imagePreview && <img src={imagePreview} alt="Preview" />}
 * {error && <p>{error.message}</p>}
 * <button onClick={removeImage}>Supprimer</button>
 */
export function useImageUpload() {
  const [imageFile, setImageFile] = useState(null);
  const [imagePreview, setImagePreview] = useState(null);
  const [isCompressing, setIsCompressing] = useState(false);
  const [error, setError] = useState(null);

  /**
   * S√©lectionner une image depuis un input file
   * 
   * @param {Event} event - Event du input file
   * @returns {Promise<void>}
   */
  const selectImage = useCallback(async (event) => {
    try {
      setError(null);

      const file = event.target.files?.[0];
      if (!file) {
        return;
      }

      console.log(`üì∑ Image s√©lectionn√©e: ${file.name} (${(file.size / 1024).toFixed(2)}KB)`);

      // Validation 1: Type MIME
      const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];
      if (!allowedTypes.includes(file.type)) {
        const errorObj = {
          code: 'INVALID_TYPE',
          message: 'Type de fichier non autoris√©. Formats accept√©s: JPEG, PNG, WebP'
        };
        setError(errorObj);
        console.error('‚ùå', errorObj.message);
        return;
      }

      // Validation 2: Taille max 5MB (avant compression)
      const maxSize = 5 * 1024 * 1024; // 5MB
      if (file.size > maxSize) {
        const errorObj = {
          code: 'FILE_TOO_LARGE',
          message: `Fichier trop volumineux (max 5MB). Taille actuelle: ${(file.size / 1024 / 1024).toFixed(2)}MB`
        };
        setError(errorObj);
        console.error('‚ùå', errorObj.message);
        return;
      }

      // Compression de l'image
      setIsCompressing(true);
      console.log('üóúÔ∏è Compression en cours...');

      const compressionResult = await reportService.compressImage(file);

      setIsCompressing(false);

      if (compressionResult.error) {
        setError(compressionResult.error);
        console.error('‚ùå Erreur compression:', compressionResult.error.message);
        return;
      }

      const compressedFile = compressionResult.compressedFile;

      // G√©n√©ration de la preview
      const previewUrl = URL.createObjectURL(compressedFile);

      setImageFile(compressedFile);
      setImagePreview(previewUrl);
      setError(null);

      console.log(`‚úÖ Image pr√™te: ${(compressedFile.size / 1024).toFixed(2)}KB (compression ${compressionResult.originalSize > 0 ? ((1 - compressedFile.size / compressionResult.originalSize) * 100).toFixed(1) : 0}%)`);

    } catch (err) {
      setIsCompressing(false);
      const errorObj = {
        code: 'UNEXPECTED_ERROR',
        message: err.message || 'Une erreur est survenue lors de la s√©lection de l\'image'
      };
      setError(errorObj);
      console.error('‚ùå Erreur inattendue selectImage:', err);
    }
  }, []);

  /**
   * Supprimer l'image s√©lectionn√©e et r√©voquer la preview
   */
  const removeImage = useCallback(() => {
    if (imagePreview) {
      URL.revokeObjectURL(imagePreview);
    }

    setImageFile(null);
    setImagePreview(null);
    setError(null);
    setIsCompressing(false);

    console.log('üóëÔ∏è Image supprim√©e');
  }, [imagePreview]);

  /**
   * R√©initialiser tout l'√©tat du hook
   */
  const resetState = useCallback(() => {
    removeImage();
  }, [removeImage]);

  /**
   * V√©rifier si une image est s√©lectionn√©e
   * 
   * @returns {boolean}
   */
  const hasImage = useCallback(() => {
    return imageFile !== null;
  }, [imageFile]);

  /**
   * Obtenir les informations sur l'image s√©lectionn√©e
   * 
   * @returns {Object|null}
   */
  const getImageInfo = useCallback(() => {
    if (!imageFile) {
      return null;
    }

    return {
      name: imageFile.name,
      size: imageFile.size,
      type: imageFile.type,
      sizeInKB: (imageFile.size / 1024).toFixed(2),
      sizeInMB: (imageFile.size / 1024 / 1024).toFixed(2)
    };
  }, [imageFile]);

  return {
    imageFile,
    imagePreview,
    isCompressing,
    error,
    selectImage,
    removeImage,
    resetState,
    hasImage,
    getImageInfo
  };
}

export default useImageUpload;

