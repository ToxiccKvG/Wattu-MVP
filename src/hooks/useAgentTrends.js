// @generated by Cursor AI (Claude) — verified by Kevin

import { useState, useEffect, useCallback } from 'react';
import * as reportApi from '@/api/reportApi';
import * as reportService from '@/services/reportService';

/**
 * Hook pour récupérer et calculer les tendances des signalements d'un agent
 * 
 * @param {string} communeId - UUID de la commune de l'agent
 * @param {number} [periodDays=30] - Nombre de jours pour la période (7, 30, 90, ou null pour tout)
 * 
 * @returns {Object}
 * @returns {Array} trends - Évolution des signalements dans le temps
 * @returns {Object} byType - Répartition par type
 * @returns {Object} byStatus - Répartition par statut
 * @returns {Object} byPriority - Répartition par priorité
 * @returns {boolean} loading - État de chargement
 * @returns {Object|null} error - Erreur éventuelle
 * @returns {Function} refetch - Fonction pour recharger les données
 * 
 * @example
 * const { trends, byType, byStatus, loading } = useAgentTrends(communeId, 30);
 */
export function useAgentTrends(communeId, periodDays = 30) {
  const [trends, setTrends] = useState([]);
  const [byType, setByType] = useState({});
  const [byStatus, setByStatus] = useState({});
  const [byPriority, setByPriority] = useState({});
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  /**
   * Calculer la date de début selon la période
   */
  const getStartDate = useCallback((days) => {
    if (!days) return null; // Toutes les données
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);
    startDate.setHours(0, 0, 0, 0);
    return startDate;
  }, []);

  /**
   * Charger et calculer les tendances
   */
  const fetchTrends = useCallback(async () => {
    if (!communeId) {
      setLoading(false);
      return;
    }

    try {
      setLoading(true);
      setError(null);

      const startDate = getStartDate(periodDays);
      const { data: reports, error: fetchError } = await reportApi.getAgentTrendsReports(communeId, {
        startDate,
        limit: 10000
      });

      if (fetchError) {
        setError(fetchError);
        setLoading(false);
        return;
      }

      if (!reports || reports.length === 0) {
        setTrends([]);
        setByType({});
        setByStatus({});
        setByPriority({});
        setLoading(false);
        return;
      }

      // Calculer les tendances (évolution dans le temps)
      const daysToAnalyze = periodDays || 30; // Par défaut 30 jours si periodDays est null
      const calculatedTrends = calculateTrends(reports, daysToAnalyze);

      // Calculer répartition par type
      const typeDistribution = calculateByType(reports);

      // Calculer répartition par statut
      const statusDistribution = calculateByStatus(reports);

      // Calculer répartition par priorité
      const priorityDistribution = calculateByPriority(reports);

      setTrends(calculatedTrends);
      setByType(typeDistribution);
      setByStatus(statusDistribution);
      setByPriority(priorityDistribution);

    } catch (err) {
      console.error('❌ Erreur calcul tendances agent:', err);
      setError({
        message: err.message || 'Erreur lors du calcul des tendances',
        code: 'UNEXPECTED_ERROR'
      });
    } finally {
      setLoading(false);
    }
  }, [communeId, periodDays, getStartDate]);

  // Charger les données au montage et quand communeId ou periodDays change
  useEffect(() => {
    fetchTrends();
  }, [fetchTrends]);

  return {
    trends,
    byType,
    byStatus,
    byPriority,
    loading,
    error,
    refetch: fetchTrends
  };
}

/**
 * Calculer les trends (évolution dans le temps)
 */
function calculateTrends(reports, days = 30) {
  const now = new Date();
  const trends = [];

  for (let i = days - 1; i >= 0; i--) {
    const targetDate = new Date(now);
    targetDate.setDate(targetDate.getDate() - i);
    targetDate.setHours(0, 0, 0, 0);

    const nextDate = new Date(targetDate);
    nextDate.setDate(nextDate.getDate() + 1);

    const count = reports.filter(r => {
      const createdAt = new Date(r.created_at);
      return createdAt >= targetDate && createdAt < nextDate;
    }).length;

    trends.push({
      date: targetDate.toISOString().split('T')[0], // Format: 2025-10-25
      count: count
    });
  }

  return trends;
}

/**
 * Calculer la répartition par type
 */
function calculateByType(reports) {
  const types = [
    'road',
    'lighting',
    'water',
    'waste',
    'security',
    'health',
    'electricity',
    'sanitation',
    'green_spaces',
    'other'
  ];

  const distribution = {};
  types.forEach(type => {
    distribution[type] = reports.filter(r => r.type === type).length;
  });

  return distribution;
}

/**
 * Calculer la répartition par statut
 */
function calculateByStatus(reports) {
  const statuses = ['pending', 'in_progress', 'resolved', 'rejected'];
  const distribution = {};

  statuses.forEach(status => {
    distribution[status] = reports.filter(r => r.status === status).length;
  });

  return distribution;
}

/**
 * Calculer la répartition par priorité
 */
function calculateByPriority(reports) {
  const priorities = ['low', 'normal', 'high', 'urgent'];
  const distribution = {};

  priorities.forEach(priority => {
    distribution[priority] = reports.filter(r => r.priority === priority).length;
  });

  return distribution;
}

export default useAgentTrends;

