// @generated by Cursor AI (Claude) â€” verified by Kevin

import { useState, useEffect, useCallback, useRef } from 'react';
import { toast } from 'sonner';
import { useTranslation } from 'react-i18next';
import supabase from '@/config/supabase';

/**
 * Hook useNotifications - Gestion des notifications pour les citoyens
 * 
 * FonctionnalitÃ©s :
 * - Abonnement Realtime aux changements de statut des signalements
 * - Affichage de toasts lors des changements
 * - Historique des notifications
 * - PrÃ©fÃ©rences de notification (opt-in/opt-out)
 * 
 * @param {string} userId - ID de l'utilisateur connectÃ©
 * @param {Object} options - Options de configuration
 * @param {boolean} options.enableRealtime - Activer les mises Ã  jour en temps rÃ©el (default: true)
 * @param {boolean} options.showToasts - Afficher les toasts (default: true)
 * 
 * @returns {Object} - { notifications, unreadCount, markAsRead, clearAll, isSubscribed }
 * 
 * @example
 * const { notifications, unreadCount, markAsRead } = useNotifications(user?.id);
 */
export function useNotifications(userId, options = {}) {
  const { t } = useTranslation('common');
  const { enableRealtime = true, showToasts = true } = options;

  const [notifications, setNotifications] = useState([]);
  const [unreadCount, setUnreadCount] = useState(0);
  const [isSubscribed, setIsSubscribed] = useState(false);
  
  const channelRef = useRef(null);
  const notificationsRef = useRef([]);

  // Synchroniser notifications avec ref pour Ã©viter les problÃ¨mes de closure
  useEffect(() => {
    notificationsRef.current = notifications;
  }, [notifications]);

  /**
   * CrÃ©er une notification Ã  partir d'un changement de statut
   */
  const createNotification = useCallback((report, oldStatus, newStatus) => {
    const statusLabels = {
      pending: t('notifications.status.pending', { defaultValue: 'En attente' }),
      in_progress: t('notifications.status.in_progress', { defaultValue: 'En cours' }),
      resolved: t('notifications.status.resolved', { defaultValue: 'RÃ©solu' }),
      rejected: t('notifications.status.rejected', { defaultValue: 'RejetÃ©' }),
    };

    const statusMessages = {
      pending: t('notifications.message.pending', { 
        defaultValue: 'Votre signalement a Ã©tÃ© reÃ§u et est en attente de traitement.' 
      }),
      in_progress: t('notifications.message.in_progress', { 
        defaultValue: 'Votre signalement est maintenant en cours de traitement.' 
      }),
      resolved: t('notifications.message.resolved', { 
        defaultValue: 'Votre signalement a Ã©tÃ© rÃ©solu !' 
      }),
      rejected: t('notifications.message.rejected', { 
        defaultValue: 'Votre signalement a Ã©tÃ© rejetÃ©.' 
      }),
    };

    return {
      id: `${report.id}-${Date.now()}`,
      reportId: report.id,
      type: 'status_change',
      title: t('notifications.title.statusChange', { 
        defaultValue: 'Statut mis Ã  jour' 
      }),
      message: statusMessages[newStatus] || t('notifications.message.unknown', { 
        defaultValue: 'Le statut de votre signalement a changÃ©.' 
      }),
      oldStatus,
      newStatus,
      statusLabel: statusLabels[newStatus] || newStatus,
      read: false,
      createdAt: new Date().toISOString(),
      reportType: report.type || 'autre',
      commune: report.commune?.name || report.commune_name || 'Inconnu',
    };
  }, [t]);

  /**
   * Ajouter une notification et afficher un toast
   */
  const addNotification = useCallback((notification) => {
    setNotifications((prev) => {
      const updated = [notification, ...prev].slice(0, 50); // Garder max 50 notifications
      return updated;
    });
    setUnreadCount((prev) => prev + 1);

    // Afficher un toast si activÃ©
    if (showToasts) {
      const toastType = notification.newStatus === 'resolved' ? 'success' : 
                       notification.newStatus === 'rejected' ? 'error' : 
                       'info';
      
      toast[toastType](notification.title, {
        description: notification.message,
        duration: 5000,
      });
    }
  }, [showToasts]);

  /**
   * Marquer une notification comme lue
   */
  const markAsRead = useCallback((notificationId) => {
    setNotifications((prev) =>
      prev.map((notif) =>
        notif.id === notificationId ? { ...notif, read: true } : notif
      )
    );
    setUnreadCount((prev) => Math.max(0, prev - 1));
  }, []);

  /**
   * Marquer toutes les notifications comme lues
   */
  const markAllAsRead = useCallback(() => {
    setNotifications((prev) =>
      prev.map((notif) => ({ ...notif, read: true }))
    );
    setUnreadCount(0);
  }, []);

  /**
   * Supprimer une notification
   */
  const removeNotification = useCallback((notificationId) => {
    setNotifications((prev) => {
      const notif = prev.find((n) => n.id === notificationId);
      if (notif && !notif.read) {
        setUnreadCount((count) => Math.max(0, count - 1));
      }
      return prev.filter((n) => n.id !== notificationId);
    });
  }, []);

  /**
   * Supprimer toutes les notifications
   */
  const clearAll = useCallback(() => {
    setNotifications([]);
    setUnreadCount(0);
  }, []);

  /**
   * S'abonner aux changements de statut des signalements via Realtime
   */
  useEffect(() => {
    if (!userId || !enableRealtime) {
      setIsSubscribed(false);
      return;
    }

    console.log('ðŸ”” Abonnement Realtime aux signalements pour:', userId);

    // CrÃ©er un canal pour Ã©couter les changements sur la table reports
    const channel = supabase
      .channel(`reports:${userId}`)
      .on(
        'postgres_changes',
        {
          event: 'UPDATE',
          schema: 'public',
          table: 'reports',
          filter: `citizen_user_id=eq.${userId}`, // Seulement les signalements de cet utilisateur
        },
        (payload) => {
          console.log('ðŸ“¢ Changement dÃ©tectÃ©:', payload);
          
          const report = payload.new;
          const oldStatus = payload.old?.status;
          const newStatus = report.status;

          // Ignorer si le statut n'a pas changÃ©
          if (oldStatus === newStatus) {
            return;
          }

          // CrÃ©er et ajouter la notification
          const notification = createNotification(report, oldStatus, newStatus);
          addNotification(notification);
        }
      )
      .subscribe((status) => {
        console.log('ðŸ“¡ Statut abonnement Realtime:', status);
        setIsSubscribed(status === 'SUBSCRIBED');
        
        if (status === 'SUBSCRIBED') {
          console.log('âœ… Abonnement Realtime actif');
        } else if (status === 'CHANNEL_ERROR') {
          console.error('âŒ Erreur abonnement Realtime');
        }
      });

    channelRef.current = channel;

    // Nettoyer l'abonnement au dÃ©montage
    return () => {
      console.log('ðŸ”• DÃ©sabonnement Realtime');
      if (channelRef.current) {
        supabase.removeChannel(channelRef.current);
        channelRef.current = null;
      }
      setIsSubscribed(false);
    };
  }, [userId, enableRealtime, createNotification, addNotification]);

  return {
    notifications,
    unreadCount,
    isSubscribed,
    markAsRead,
    markAllAsRead,
    removeNotification,
    clearAll,
  };
}

