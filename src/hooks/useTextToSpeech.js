// @generated by Cursor AI (Claude) ‚Äî verified by Kevin

import { useState, useEffect, useCallback, useRef } from 'react';

/**
 * Custom Hook pour la synth√®se vocale (Text-to-Speech)
 * 
 * Utilise l'API Web Speech API SpeechSynthesis pour convertir du texte en parole.
 * 
 * Fonctionnalit√©s :
 * - Parler un texte avec une voix configur√©e
 * - Arr√™ter la parole en cours
 * - G√©rer les erreurs (API non support√©e, voix non disponible)
 * - D√©tecter quand la parole est termin√©e
 * - Support multilingue (FR, Wolof)
 * 
 * @param {Object} [options] - Options du hook
 * @param {string} [options.language='fr-FR'] - Langue de la voix
 * @param {number} [options.rate=1] - Vitesse de parole (0.1 √† 10)
 * @param {number} [options.pitch=1] - Hauteur de la voix (0 √† 2)
 * @param {number} [options.volume=1] - Volume (0 √† 1)
 * 
 * @returns {Object} √âtat et fonctions de synth√®se vocale
 * @property {boolean} isSpeaking - true si la synth√®se vocale est en cours
 * @property {boolean} isSupported - true si l'API est support√©e
 * @property {Object|null} error - Erreur √©ventuelle
 * @property {function} speak - Parler un texte
 * @property {function} stop - Arr√™ter la parole en cours
 * @property {function} pause - Mettre en pause (si support√©)
 * @property {function} resume - Reprendre (si support√©)
 * 
 * @example
 * const { speak, stop, isSpeaking, isSupported } = useTextToSpeech({ language: 'fr-FR' });
 * 
 * // Parler un texte
 * speak("Bonjour ! Je vais vous aider √† cr√©er votre compte.");
 * 
 * // Arr√™ter
 * if (isSpeaking) {
 *   stop();
 * }
 */
export function useTextToSpeech(options = {}) {
  const {
    language = 'fr-FR',
    rate = 1,
    pitch = 1,
    volume = 1,
  } = options;

  const [isSpeaking, setIsSpeaking] = useState(false);
  const [isSupported, setIsSupported] = useState(false);
  const [error, setError] = useState(null);
  
  const utteranceRef = useRef(null);
  const onEndCallbackRef = useRef(null);
  const onStartCallbackRef = useRef(null);

  /**
   * V√©rifier si l'API SpeechSynthesis est support√©e
   */
  useEffect(() => {
    if ('speechSynthesis' in window) {
      setIsSupported(true);
      setError(null);
    } else {
      setIsSupported(false);
      setError({
        code: 'NOT_SUPPORTED',
        message: 'La synth√®se vocale n\'est pas support√©e par ce navigateur',
      });
    }
  }, []);

  /**
   * Nettoyer lors du d√©montage
   */
  useEffect(() => {
    return () => {
      if (utteranceRef.current && isSpeaking) {
        window.speechSynthesis.cancel();
      }
    };
  }, [isSpeaking]);

  /**
   * Parler un texte
   * 
   * @param {string} text - Texte √† prononcer
   * @param {Object} [overrides] - Options √† surcharger (language, rate, pitch, volume)
   * @param {Function} [onEnd] - Callback appel√© quand la parole est termin√©e
   * @param {Function} [onStart] - Callback appel√© quand la parole commence
   * 
   * @returns {Promise<void>}
   */
  const speak = useCallback(async (text, overrides = {}, onEnd = null, onStart = null) => {
    if (!isSupported) {
      setError({
        code: 'NOT_SUPPORTED',
        message: 'La synth√®se vocale n\'est pas support√©e',
      });
      return;
    }

    if (!text || typeof text !== 'string' || text.trim() === '') {
      setError({
        code: 'INVALID_TEXT',
        message: 'Le texte √† prononcer ne peut pas √™tre vide',
      });
      return;
    }

    try {
      // Arr√™ter toute parole en cours
      window.speechSynthesis.cancel();

      // Cr√©er un nouvel utterance
      const utterance = new SpeechSynthesisUtterance(text);
      
      // Configurer les options
      utterance.lang = overrides.language || language;
      utterance.rate = overrides.rate !== undefined ? overrides.rate : rate;
      utterance.pitch = overrides.pitch !== undefined ? overrides.pitch : pitch;
      utterance.volume = overrides.volume !== undefined ? overrides.volume : volume;

      // Stocker la r√©f√©rence
      utteranceRef.current = utterance;
      onEndCallbackRef.current = onEnd;
      onStartCallbackRef.current = onStart;

      // G√©rer les √©v√©nements
      utterance.onstart = () => {
        setIsSpeaking(true);
        setError(null);
        console.log('üîä Synth√®se vocale d√©marr√©e:', text.substring(0, 50) + '...');
        
        // Appeler le callback onStart si fourni
        if (onStartCallbackRef.current) {
          onStartCallbackRef.current();
          onStartCallbackRef.current = null;
        }
      };

      utterance.onend = () => {
        setIsSpeaking(false);
        utteranceRef.current = null;
        onStartCallbackRef.current = null;
        console.log('‚úÖ Synth√®se vocale termin√©e');
        
        // Appeler le callback si fourni
        if (onEndCallbackRef.current) {
          onEndCallbackRef.current();
          onEndCallbackRef.current = null;
        }
      };

      utterance.onerror = (event) => {
        setIsSpeaking(false);
        utteranceRef.current = null;
        onStartCallbackRef.current = null;
        
        const errorMessage = event.error || 'Erreur lors de la synth√®se vocale';
        setError({
          code: 'SPEECH_ERROR',
          message: errorMessage,
          originalError: event,
        });
        
        console.error('‚ùå Erreur synth√®se vocale:', event);
        
        // Appeler le callback m√™me en cas d'erreur
        if (onEndCallbackRef.current) {
          onEndCallbackRef.current();
          onEndCallbackRef.current = null;
        }
      };

      // D√©marrer la synth√®se vocale
      window.speechSynthesis.speak(utterance);

    } catch (err) {
      setIsSpeaking(false);
      setError({
        code: 'UNEXPECTED_ERROR',
        message: err.message || 'Une erreur inattendue est survenue',
        originalError: err,
      });
      console.error('‚ùå Erreur inattendue speak:', err);
    }
  }, [isSupported, language, rate, pitch, volume]);

  /**
   * Arr√™ter la parole en cours
   */
  const stop = useCallback(() => {
    if (window.speechSynthesis && isSpeaking) {
      window.speechSynthesis.cancel();
      setIsSpeaking(false);
      utteranceRef.current = null;
      onEndCallbackRef.current = null;
      onStartCallbackRef.current = null;
      console.log('‚èπÔ∏è Synth√®se vocale arr√™t√©e');
    }
  }, [isSpeaking]);

  /**
   * Mettre en pause (si support√©)
   */
  const pause = useCallback(() => {
    if (window.speechSynthesis && isSpeaking) {
      window.speechSynthesis.pause();
      console.log('‚è∏Ô∏è Synth√®se vocale mise en pause');
    }
  }, [isSpeaking]);

  /**
   * Reprendre (si support√©)
   */
  const resume = useCallback(() => {
    if (window.speechSynthesis && !isSpeaking) {
      window.speechSynthesis.resume();
      console.log('‚ñ∂Ô∏è Synth√®se vocale reprise');
    }
  }, [isSpeaking]);

  return {
    isSpeaking,
    isSupported,
    error,
    speak,
    stop,
    pause,
    resume,
  };
}

export default useTextToSpeech;

