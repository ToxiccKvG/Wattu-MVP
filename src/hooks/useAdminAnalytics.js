// @generated by Cursor AI (Claude) — verified by Kevin

import { useState, useEffect, useCallback } from 'react';
import * as reportApi from '@/api/reportApi';
import * as reportService from '@/services/reportService';

/**
 * Hook pour récupérer et calculer les analytics globales pour l'admin
 * 
 * @param {number} [periodDays=30] - Nombre de jours pour la période (7, 30, 90, ou null pour tout)
 * 
 * @returns {Object}
 * @returns {Array} trends - Évolution des signalements dans le temps
 * @returns {Object} byType - Répartition par type (global, toutes communes)
 * @returns {Object} byStatus - Répartition par statut (global)
 * @returns {Object} byPriority - Répartition par priorité (global)
 * @returns {Array} byCommune - Répartition par commune (top 10)
 * @returns {boolean} loading - État de chargement
 * @returns {Object|null} error - Erreur éventuelle
 * @returns {Function} refetch - Fonction pour recharger les données
 * 
 * @example
 * const { trends, byType, byStatus, loading } = useAdminAnalytics(30);
 */
export function useAdminAnalytics(periodDays = 30) {
  const [trends, setTrends] = useState([]);
  const [byType, setByType] = useState({});
  const [byStatus, setByStatus] = useState({});
  const [byPriority, setByPriority] = useState({});
  const [byCommune, setByCommune] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  /**
   * Calculer la date de début selon la période
   */
  const getStartDate = useCallback((days) => {
    if (!days) return null; // Toutes les données
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);
    startDate.setHours(0, 0, 0, 0);
    return startDate;
  }, []);

  /**
   * Charger et calculer les analytics
   */
  const fetchAnalytics = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      const startDate = getStartDate(periodDays);
      
      // Récupérer tous les signalements (admin voit tout)
      const { data: reports, error: fetchError } = await reportApi.getAdminReports({
        limit: 10000,
        // Note: On filtre par date côté client pour plus de flexibilité
      });

      if (fetchError) {
        setError(fetchError);
        setLoading(false);
        return;
      }

      if (!reports || reports.length === 0) {
        setTrends([]);
        setByType({});
        setByStatus({});
        setByPriority({});
        setByCommune([]);
        setLoading(false);
        return;
      }

      // Filtrer par date si nécessaire
      let filteredReports = reports;
      if (startDate) {
        filteredReports = reports.filter(r => {
          const createdAt = new Date(r.created_at);
          return createdAt >= startDate;
        });
      }

      // Calculer les tendances (évolution dans le temps)
      const daysToAnalyze = periodDays || 30; // Par défaut 30 jours si periodDays est null
      const calculatedTrends = calculateTrends(filteredReports, daysToAnalyze);

      // Calculer répartition par type
      const typeDistribution = calculateByType(filteredReports);

      // Calculer répartition par statut
      const statusDistribution = calculateByStatus(filteredReports);

      // Calculer répartition par priorité
      const priorityDistribution = calculateByPriority(filteredReports);

      // Calculer répartition par commune (top 10)
      const communeDistribution = calculateByCommune(filteredReports, 10);

      setTrends(calculatedTrends);
      setByType(typeDistribution);
      setByStatus(statusDistribution);
      setByPriority(priorityDistribution);
      setByCommune(communeDistribution);

    } catch (err) {
      console.error('❌ Erreur calcul analytics admin:', err);
      setError({
        message: err.message || 'Erreur lors du calcul des analytics',
        code: 'UNEXPECTED_ERROR'
      });
    } finally {
      setLoading(false);
    }
  }, [periodDays, getStartDate]);

  // Charger les données au montage et quand periodDays change
  useEffect(() => {
    fetchAnalytics();
  }, [fetchAnalytics]);

  return {
    trends,
    byType,
    byStatus,
    byPriority,
    byCommune,
    loading,
    error,
    refetch: fetchAnalytics
  };
}

/**
 * Calculer les trends (évolution dans le temps)
 */
function calculateTrends(reports, days = 30) {
  const now = new Date();
  const trends = [];

  for (let i = days - 1; i >= 0; i--) {
    const targetDate = new Date(now);
    targetDate.setDate(targetDate.getDate() - i);
    targetDate.setHours(0, 0, 0, 0);

    const nextDate = new Date(targetDate);
    nextDate.setDate(nextDate.getDate() + 1);

    const count = reports.filter(r => {
      const createdAt = new Date(r.created_at);
      return createdAt >= targetDate && createdAt < nextDate;
    }).length;

    trends.push({
      date: targetDate.toISOString().split('T')[0], // Format: 2025-10-25
      count: count
    });
  }

  return trends;
}

/**
 * Calculer la répartition par type
 */
function calculateByType(reports) {
  // Types réels utilisés dans la base de données
  const types = [
    'voirie',
    'eclairage',
    'eau',
    'dechets',
    'securite',
    'assainissement',
    'espaces_verts',
    'transport',
    'autre'
  ];

  const distribution = {};
  types.forEach(type => {
    distribution[type] = reports.filter(r => r.type === type).length;
  });

  return distribution;
}

/**
 * Calculer la répartition par statut
 */
function calculateByStatus(reports) {
  const statuses = ['pending', 'in_progress', 'resolved', 'rejected'];
  const distribution = {};

  statuses.forEach(status => {
    distribution[status] = reports.filter(r => r.status === status).length;
  });

  return distribution;
}

/**
 * Calculer la répartition par priorité
 */
function calculateByPriority(reports) {
  const priorities = ['low', 'normal', 'high', 'urgent'];
  const distribution = {};

  priorities.forEach(priority => {
    distribution[priority] = reports.filter(r => r.priority === priority).length;
  });

  return distribution;
}

/**
 * Calculer la répartition par commune (top N)
 */
function calculateByCommune(reports, limit = 10) {
  // Grouper par commune_id
  const communeMap = {};
  
  reports.forEach(report => {
    if (report.commune_id) {
      const communeId = report.commune_id;
      if (!communeMap[communeId]) {
        communeMap[communeId] = {
          commune_id: communeId,
          commune_name: report.commune?.name || 'Commune inconnue',
          count: 0
        };
      }
      communeMap[communeId].count++;
    }
  });

  // Convertir en array et trier par count décroissant
  const communeArray = Object.values(communeMap)
    .sort((a, b) => b.count - a.count)
    .slice(0, limit);

  return communeArray;
}

export default useAdminAnalytics;

