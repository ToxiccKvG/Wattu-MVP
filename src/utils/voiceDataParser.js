// @generated by Cursor AI (Claude) — verified by Kevin

import { extractEmailWithAI, identifyCommuneWithAI, normalizeAddressWithAI } from '@/services/geminiParserService';

/**
 * Utilitaires pour parser les réponses vocales
 * 
 * Fonctionnalités :
 * - Conversion nombres français → chiffres ("trente-cinq" → 35)
 * - Extraction email depuis texte (avec fallback IA Gemini)
 * - Extraction téléphone depuis texte
 * - Normalisation texte (majuscules, accents)
 * - Recherche de commune par nom (avec fallback IA Gemini)
 * - Normalisation d'adresse (avec fallback IA Gemini)
 */

/**
 * Dictionnaire des nombres en français
 */
const FRENCH_NUMBERS = {
  'zéro': 0, 'zero': 0,
  'un': 1, 'une': 1,
  'deux': 2,
  'trois': 3,
  'quatre': 4,
  'cinq': 5,
  'six': 6,
  'sept': 7,
  'huit': 8,
  'neuf': 9,
  'dix': 10,
  'onze': 11,
  'douze': 12,
  'treize': 13,
  'quatorze': 14,
  'quinze': 15,
  'seize': 16,
  'dix-sept': 17, 'dix sept': 17,
  'dix-huit': 18, 'dix huit': 18,
  'dix-neuf': 19, 'dix neuf': 19,
  'vingt': 20,
  'vingt-et-un': 21, 'vingt et un': 21, 'vingt-un': 21,
  'vingt-deux': 22, 'vingt deux': 22,
  'vingt-trois': 23, 'vingt trois': 23,
  'vingt-quatre': 24, 'vingt quatre': 24,
  'vingt-cinq': 25, 'vingt cinq': 25,
  'vingt-six': 26, 'vingt six': 26,
  'vingt-sept': 27, 'vingt sept': 27,
  'vingt-huit': 28, 'vingt huit': 28,
  'vingt-neuf': 29, 'vingt neuf': 29,
  'trente': 30,
  'trente-et-un': 31, 'trente et un': 31, 'trente-un': 31,
  'trente-deux': 32, 'trente deux': 32,
  'trente-trois': 33, 'trente trois': 33,
  'trente-quatre': 34, 'trente quatre': 34,
  'trente-cinq': 35, 'trente cinq': 35,
  'trente-six': 36, 'trente six': 36,
  'trente-sept': 37, 'trente sept': 37,
  'trente-huit': 38, 'trente huit': 38,
  'trente-neuf': 39, 'trente neuf': 39,
  'quarante': 40,
  'cinquante': 50,
  'soixante': 60,
  'soixante-dix': 70, 'soixante dix': 70,
  'quatre-vingt': 80, 'quatre vingt': 80,
  'quatre-vingt-dix': 90, 'quatre vingt dix': 90,
  'cent': 100,
};

/**
 * Convertir un nombre en français en chiffre
 * 
 * @param {string} text - Texte contenant un nombre en français
 * @returns {number|null} - Nombre converti ou null si non trouvé
 * 
 * @example
 * parseFrenchNumber("trente-cinq") // → 35
 * parseFrenchNumber("j'ai trente-cinq ans") // → 35
 * parseFrenchNumber("35") // → 35
 */
export function parseFrenchNumber(text) {
  if (!text || typeof text !== 'string') {
    return null;
  }

  // Nettoyer le texte
  const cleanText = text.toLowerCase().trim();

  // Essayer d'abord de parser directement un nombre
  const directNumber = parseInt(cleanText.replace(/\D/g, ''));
  if (!isNaN(directNumber) && directNumber > 0) {
    return directNumber;
  }

  // Chercher dans le dictionnaire
  for (const [french, number] of Object.entries(FRENCH_NUMBERS)) {
    if (cleanText.includes(french)) {
      return number;
    }
  }

  // Essayer de parser des nombres composés (ex: "vingt-cinq")
  const words = cleanText.split(/[\s-]+/);
  let total = 0;
  let found = false;

  for (let i = 0; i < words.length; i++) {
    const word = words[i].toLowerCase();
    if (FRENCH_NUMBERS[word] !== undefined) {
      const num = FRENCH_NUMBERS[word];
      if (num >= 20 && num < 100) {
        total += num;
      } else if (num < 20) {
        total += num;
      }
      found = true;
    }
  }

  return found && total > 0 ? total : null;
}

/**
 * Extraire une adresse email depuis un texte
 * 
 * Gère les transcriptions vocales courantes :
 * - "at" ou "a" → "@"
 * - "point" ou "dot" → "."
 * - "gmail point com" → "gmail.com"
 * 
 * Utilise Gemini AI en fallback si le parsing classique échoue.
 * 
 * @param {string} text - Texte contenant potentiellement un email
 * @returns {Promise<string|null>} - Email extrait ou null si non trouvé
 * 
 * @example
 * await extractEmail("mon email est amadou.diallo@gmail.com") // → "amadou.diallo@gmail.com"
 * await extractEmail("amadou point diallo at gmail point com") // → "amadou.diallo@gmail.com"
 * await extractEmail("amadou a gmail point com") // → "amadou@gmail.com"
 */
export async function extractEmail(text) {
  if (!text || typeof text !== 'string') {
    return null;
  }

  // D'abord, essayer de trouver un email déjà formaté
  const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g;
  const matches = text.match(emailRegex);

  if (matches && matches.length > 0) {
    return matches[0].toLowerCase().trim();
  }

  // Si pas d'email trouvé, essayer de parser depuis la transcription vocale
  let cleanText = text.toLowerCase().trim();
  
  // Remplacer les mots courants de transcription vocale
  // "at" ou "a" → "@" (mais pas si c'est juste "a" seul)
  cleanText = cleanText.replace(/\s+at\s+/g, '@');
  cleanText = cleanText.replace(/\s+a\s+(gmail|yahoo|hotmail|outlook|icloud)/gi, '@$1');
  
  // "point" ou "dot" → "."
  cleanText = cleanText.replace(/\s+point\s+/g, '.');
  cleanText = cleanText.replace(/\s+dot\s+/g, '.');
  
  // Nettoyer les espaces multiples
  cleanText = cleanText.replace(/\s+/g, '');
  
  // Vérifier si ça ressemble à un email maintenant
  if (emailRegex.test(cleanText)) {
    return cleanText;
  }

  // Essayer de construire un email depuis des patterns vocaux
  // Pattern: "nom point prenom at provider point extension"
  // Ex: "amadou point diallo at gmail point com"
  const vocalPattern = /([a-z0-9]+(?:\s+point\s+[a-z0-9]+)*)\s+(?:at|a)\s+([a-z]+)\s+point\s+([a-z]{2,})/i;
  const vocalMatch = text.match(vocalPattern);
  
  if (vocalMatch) {
    const localPart = vocalMatch[1].replace(/\s+point\s+/gi, '.').replace(/\s+/g, '');
    const domain = vocalMatch[2];
    const extension = vocalMatch[3];
    const constructedEmail = `${localPart}@${domain}.${extension}`;
    
    if (emailRegex.test(constructedEmail)) {
      return constructedEmail.toLowerCase();
    }
  }

  // Dernier essai : chercher des patterns comme "nom@provider.com" même avec espaces
  const spacedPattern = /([a-z0-9._-]+)\s*[@a]\s*([a-z0-9.-]+)\s*[.\s]+\s*([a-z]{2,})/i;
  const spacedMatch = text.match(spacedPattern);
  
  if (spacedMatch) {
    const local = spacedMatch[1].replace(/\s+/g, '');
    const domain = spacedMatch[2].replace(/\s+/g, '');
    const ext = spacedMatch[3].replace(/\s+/g, '');
    const constructed = `${local}@${domain}.${ext}`;
    
    if (emailRegex.test(constructed)) {
      return constructed.toLowerCase();
    }
  }

  return null;
}

/**
 * Extraire un numéro de téléphone depuis un texte
 * 
 * @param {string} text - Texte contenant potentiellement un numéro de téléphone
 * @returns {string|null} - Numéro de téléphone extrait (chiffres uniquement) ou null
 * 
 * @example
 * extractPhone("77 123 45 67") // → "771234567"
 * extractPhone("mon numéro est 77 123 45 67") // → "771234567"
 * extractPhone("+221 77 123 45 67") // → "221771234567"
 */
export function extractPhone(text) {
  if (!text || typeof text !== 'string') {
    return null;
  }

  // Extraire tous les chiffres
  const digits = text.replace(/\D/g, '');

  if (digits.length === 0) {
    return null;
  }

  // Pour le Sénégal, les numéros commencent souvent par 77, 78, 76, 70, etc.
  // Format attendu : 9 chiffres (sans indicatif) ou 12 chiffres (avec indicatif +221)
  if (digits.length >= 9) {
    // Si commence par 221 (indicatif Sénégal), prendre les 9 derniers chiffres
    if (digits.startsWith('221') && digits.length >= 12) {
      return digits.slice(-9);
    }
    // Sinon, prendre les 9 derniers chiffres
    return digits.slice(-9);
  }

  return digits;
}

/**
 * Normaliser un texte (majuscules, accents, espaces)
 * 
 * Pour les adresses, on garde plus de détails et on ne normalise pas trop
 * pour préserver les informations importantes.
 * 
 * @param {string} text - Texte à normaliser
 * @param {boolean} preserveCase - Si true, préserver la casse (pour adresses)
 * @returns {string} - Texte normalisé
 * 
 * @example
 * normalizeText("  AMADOU  ") // → "Amadou"
 * normalizeText("dakar plateau") // → "Dakar Plateau"
 * normalizeText("rue 12 dakar", true) // → "Rue 12 Dakar" (préserve les détails)
 */
export function normalizeText(text, preserveCase = false) {
  if (!text || typeof text !== 'string') {
    return '';
  }

  // Nettoyer les espaces multiples
  let normalized = text.trim().replace(/\s+/g, ' ');

  // Pour les adresses, on garde plus de détails
  if (preserveCase) {
    // Mettre en forme mais préserver les nombres et détails
    normalized = normalized
      .split(' ')
      .map(word => {
        if (word.length === 0) return '';
        // Si c'est un nombre, le garder tel quel
        if (/^\d+$/.test(word)) {
          return word;
        }
        // Sinon, première lettre en majuscule
        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
      })
      .join(' ');
  } else {
    // Mettre en forme standard (première lettre en majuscule, reste en minuscule)
    normalized = normalized
      .split(' ')
      .map(word => {
        if (word.length === 0) return '';
        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
      })
      .join(' ');
  }

  return normalized;
}

/**
 * Calculer la similarité entre deux chaînes (Levenshtein simplifié)
 * 
 * @param {string} str1 - Première chaîne
 * @param {string} str2 - Deuxième chaîne
 * @returns {number} - Score de similarité (0-1, 1 = identique)
 */
function calculateSimilarity(str1, str2) {
  const longer = str1.length > str2.length ? str1 : str2;
  const shorter = str1.length > str2.length ? str2 : str1;
  
  if (longer.length === 0) {
    return 1.0;
  }
  
  // Calcul simple de distance (nombre de caractères différents)
  let distance = 0;
  for (let i = 0; i < shorter.length; i++) {
    if (longer[i] !== shorter[i]) {
      distance++;
    }
  }
  distance += (longer.length - shorter.length);
  
  return (longer.length - distance) / longer.length;
}

/**
 * Rechercher une commune par nom (fuzzy matching amélioré)
 * 
 * Gère :
 * - Recherche exacte
 * - Recherche partielle
 * - Recherche par mots-clés
 * - Similarité de chaînes (pour gérer les erreurs de transcription)
 * - Recherche dans la région aussi
 * - Fallback vers Gemini AI si le parsing classique échoue
 * 
 * @param {string} text - Texte contenant le nom de la commune
 * @param {Array} communes - Liste des communes disponibles
 * @returns {Promise<Object|null>} - Commune trouvée ou null
 * 
 * @example
 * const communes = [{ id: '1', name: 'Dakar', region: 'Dakar' }, ...];
 * await findCommuneInText("dakar plateau", communes) // → { id: '1', name: 'Dakar', region: 'Dakar' }
 * await findCommuneInText("dakar", communes) // → { id: '1', name: 'Dakar', region: 'Dakar' }
 * await findCommuneInText("saint louis", communes) // → { id: '2', name: 'Saint-Louis', region: 'Saint-Louis' }
 */
export async function findCommuneInText(text, communes = []) {
  if (!text || typeof text !== 'string' || !Array.isArray(communes) || communes.length === 0) {
    return null;
  }

  const cleanText = text.toLowerCase().trim().replace(/[^\w\s-]/g, ''); // Nettoyer les caractères spéciaux

  // 1. Recherche exacte (nom complet)
  const exactMatch = communes.find(c => 
    c.name.toLowerCase() === cleanText
  );
  if (exactMatch) {
    return exactMatch;
  }

  // 2. Recherche exacte sans accents et caractères spéciaux
  const normalizeForSearch = (str) => {
    return str.toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '') // Supprimer les accents
      .replace(/[^\w\s-]/g, '') // Supprimer caractères spéciaux
      .replace(/\s+/g, ' ')
      .trim();
  };

  const normalizedText = normalizeForSearch(cleanText);
  const exactNormalizedMatch = communes.find(c => 
    normalizeForSearch(c.name) === normalizedText
  );
  if (exactNormalizedMatch) {
    return exactNormalizedMatch;
  }

  // 3. Recherche partielle (contient)
  const partialMatch = communes.find(c => {
    const normalizedCommune = normalizeForSearch(c.name);
    return normalizedCommune.includes(normalizedText) ||
           normalizedText.includes(normalizedCommune);
  });
  if (partialMatch) {
    return partialMatch;
  }

  // 4. Recherche par mots-clés (ex: "dakar plateau" → "Dakar")
  const words = normalizedText.split(/\s+/).filter(w => w.length >= 2);
  for (const word of words) {
    if (word.length >= 3) {
      const wordMatch = communes.find(c => {
        const normalizedCommune = normalizeForSearch(c.name);
        const communeWords = normalizedCommune.split(/\s+/);
        return communeWords.some(cw => cw.includes(word) || word.includes(cw)) ||
               normalizedCommune.includes(word) ||
               word.includes(communeWords[0]);
      });
      if (wordMatch) {
        return wordMatch;
      }
    }
  }

  // 5. Recherche par similarité (pour gérer les erreurs de transcription)
  let bestMatch = null;
  let bestScore = 0;
  const threshold = 0.6; // Score minimum de similarité

  for (const commune of communes) {
    const normalizedCommune = normalizeForSearch(commune.name);
    const score = calculateSimilarity(normalizedText, normalizedCommune);
    
    // Bonus si le texte contient un mot de la commune
    const communeWords = normalizedCommune.split(/\s+/);
    const hasCommonWord = words.some(w => 
      communeWords.some(cw => cw.includes(w) || w.includes(cw))
    );
    const finalScore = hasCommonWord ? score + 0.2 : score;
    
    if (finalScore > bestScore && finalScore >= threshold) {
      bestScore = finalScore;
      bestMatch = commune;
    }
  }

  if (bestMatch) {
    return bestMatch;
  }

  // 6. Recherche dans les régions aussi (ex: "dakar" peut être une région)
  const regionMatch = communes.find(c => 
    normalizeForSearch(c.region) === normalizedText ||
    normalizeForSearch(c.region).includes(normalizedText) ||
    normalizedText.includes(normalizeForSearch(c.region))
  );
  if (regionMatch) {
    return regionMatch;
  }

  // 7. Si le parsing classique échoue, essayer avec Gemini AI
  try {
    const { identifyCommuneWithAI } = await import('@/services/geminiParserService');
    const communeId = await identifyCommuneWithAI(text, communes);
    if (communeId) {
      const foundCommune = communes.find(c => c.id === communeId);
      if (foundCommune) {
        console.log('✅ Commune identifiée via Gemini AI:', foundCommune.name);
        return foundCommune;
      }
    }
  } catch (error) {
    console.warn('⚠️ Erreur identification commune avec Gemini (fallback):', error);
  }

  return null;
}

/**
 * Parser une réponse vocale pour un champ spécifique
 * 
 * @param {string} fieldId - ID du champ (firstName, lastName, age, commune, phone, email, address)
 * @param {string} text - Texte transcrit
 * @param {Array} [communes] - Liste des communes (nécessaire pour le champ commune)
 * @returns {Promise<any>} - Valeur parsée
 * 
 * @example
 * await parseFieldValue('age', 'trente-cinq ans') // → 35
 * await parseFieldValue('email', 'mon email est test@example.com') // → "test@example.com"
 * await parseFieldValue('phone', '77 123 45 67') // → "771234567"
 */
export async function parseFieldValue(fieldId, text, communes = []) {
  if (!text || typeof text !== 'string') {
    return null;
  }

  switch (fieldId) {
    case 'firstName':
    case 'lastName':
      return normalizeText(text);

    case 'age':
      return parseFrenchNumber(text);

    case 'commune':
    case 'commune_id':
      const commune = await findCommuneInText(text, communes);
      return commune ? commune.id : null;

    case 'phone':
      return extractPhone(text);

    case 'email':
      return await extractEmail(text);

    case 'address':
      // Pour les adresses, on préserve plus de détails
      // Essayer d'abord le parsing classique
      const normalized = normalizeText(text, true);
      // Si le résultat semble incomplet, essayer avec Gemini AI
      if (normalized.length < 10) {
        try {
          const aiAddress = await normalizeAddressWithAI(text);
          if (aiAddress && aiAddress.length >= 10) {
            console.log('✅ Adresse normalisée via Gemini AI:', aiAddress);
            return aiAddress;
          }
        } catch (error) {
          console.warn('⚠️ Erreur normalisation adresse avec Gemini (fallback):', error);
        }
      }
      return normalized;

    default:
      return text.trim();
  }
}

export default {
  parseFrenchNumber,
  extractEmail,
  extractPhone,
  normalizeText,
  findCommuneInText,
  parseFieldValue,
};

